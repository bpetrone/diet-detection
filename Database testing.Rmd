---
title: "Kleiner lab database testing"
output:
  html_document:
    df_print: paged
---

Here we are evaluating the preliminary data shared by the Kleiner lab at NCSU to determine if their metaproteomic database should be adjusted (e.g. filtering out homologs to human proteins, other ideas?) before continuing with analysis of the DFC samples.

# R setup

```{r setup, include=FALSE, echo=FALSE}
require("knitr")
opts_knit$set(root.dir = file.path(getwd(), '..'))
```

```{r libraries, echo=FALSE}
library(here) 
library(phyloseq) 
library(RColorBrewer)
library(readxl) # For parsing Excel files
library(tidyverse) 
```

# Read in files

## Current reference database

```{r }
# Read in the first sheet of the file using read_excel function
db <- read_excel(here('data', 'processed', 'DietaryDB_ForDavidLab.xlsx'), 
                 sheet = 1, 
                 n_max = 547) # Exclude annotations at end of file
head(db)
```
```{r }
# Manual updates
# Specify scientific name for tilapia
db$scientific_name[db$scientific_name == 'Tilapia'] <- 
     'Oreochromis niloticus'
# Correct misspelling for mallard duck
db$scientific_name[db$scientific_name == 'Anas platyrhynchose'] <- 
     'Anas platyrhynchos'
# Switch var. to subsp. for durum
db$scientific_name[db$scientific_name == 'Triticum turgidum var. durum'] <-
     'Triticum turgidum subsp. durum'
db$scientific_name[db$scientific_name == 'Triticum dicoccon'] <- 
     'Triticum dicoccum'
# Correct spelling of water buffalo
db$scientific_name[db$scientific_name == 'Bubalis bubalis'] <- 
     'Bubalus bubalis'
# Think something weird about formatting of "x" in Musa x paradisiaca, not being recognized
db$scientific_name[db$common_name == 'plantain'] <- 
     'Musa x paradisiaca'
# Same for Mentha x piperita
db$scientific_name[db$common_name == 'peppermint'] <- 
     'Mentha x piperita'
# Add hybrid designation for grapefruit
db$scientific_name[db$scientific_name == 'Citrus paradisi'] <- 
     'Citrus x paradisi'
# Remove zante currant, which is redundant with V. vinifera
db <- filter(db, common_name != 'zante currant')
# Switch amaranth to its homotypic synonym used by NCBI taxonomy
db$scientific_name[db$scientific_name == 'Amaranthus cruentus'] <- 
     'Amaranthus hybridus subsp. cruentus'
db$scientific_name[db$scientific_name == 'Mercenaria mercenaria, others'] <-
     'Mercenaria mercenaria'
db$scientific_name[db$scientific_name == 'Polystichum munitum and others'] <-
     'Polystichum munitum'
# Query resulted in hits for var. capitata only
db$scientific_name[db$scientific_name == 'Brassica oleracea var. capitata f. alba'] <- 
     'Brassica oleracea var. capitata'
# Switch fennel to its synonym used by NCBI taxonomy
db$scientific_name[db$scientific_name == 'Foeniculum vulgare'] <- 
     'Anethum foeniculum'
# Correct name for dragonfruit
db$scientific_name[db$scientific_name == 'Hylocereus undatus'] <- 
     'Selenicereus undatus'
# Update name for nori
db$scientific_name[db$scientific_name == 'Pyropia yezoensis'] <- 
     'Neopyropia yezoensis'
# Subspecies designation for maple (syrup)
db$scientific_name[db$scientific_name == 'Acer nigrum'] <- 
     'Acer saccharum subsp. nigrum'
``` 

```{r}
# Some entries have trailing whitespace: correct
db$scientific_name[grep('\\s$', db$scientific_name)]
db$scientific_name <- gsub('\\s$', '', db$scientific_name)
```

## Participant metaproteomic data

### Combine files

```{r }
# List files
fs <-
     here('data', 'raw',
          # '2_NewDataForDavidLab_DB2.1Search_Workflow2.0') %>%
          '3_DB2.1_5FDR_1UniquePeptide') %>%
     list.files(pattern = ".xlsx", full.names = T)

# Read and synchronize names
# Note that if sheet not specified, defaults to first sheet
dfs <- 
     lapply(fs, read_excel) %>% 
     # Rename "Found in sample" column so it's the same for each sample
     lapply(., 
            function(x){
                 # Update name
                 names(x)[grep('Found in Sample: *', names(x))] <- 'Found in Sample'
                 # Return original object
                 x
                 }
            )

# Bind together
names(dfs) <- basename(fs)
proteins.df <- bind_rows(dfs, .id = 'id')
rm(fs, dfs)
```

### Clean
```{r }
proteins.df <- 
     proteins.df %>% 
     # Clean up ID column
     separate(col = 'id', into = c('id', 'subj', 'date'),
                        sep = '_', remove = TRUE, extra = 'drop') %>% 
     # Convert date to Date type
     mutate(date = as.Date(date, format = '%d%b%y'))
```

```{r }
head(proteins.df)
```
```{r }
dim(proteins.df)
```

* 1_Proteins_IndividualResultFiles_RealisticFoodsWithMicrobiota: ??
* 2_NewDataForDavidLab_DB2.1Search_Workflow2.0: 7,632
* 3_DB2.1_5FDR_1UniquePeptide: 88,409

### Filter 

```{r }
# Filter to only food-derived proteins (this removes majority)
proteins.df <- 
     proteins.df %>% 
     filter(!grepl('Human_*', Accession)) %>% # Remove human proteins
     filter(!grepl('Microbiota_*', Accession)) # Remove microbiota proteins

dim(proteins.df)
```

```{r }
# Remove proteins labeled as not found in sample
# Very low abundance (though non-zero counts), only one from wheat
proteins.df <- 
     filter(proteins.df, 
            `Found in Sample` %in% c('High', 'Medium', NA))

dim(proteins.df)
```

### Relabel with food species

Using a combination of OS (embedded in Description column) and prefix assigned in database.

```{r }
head(proteins.df$Description)
cat('\n')
head(proteins.df$Accession)
```

```{r }
# Separate prefix into its own column

# Helper function for use inside mutate
helper <- function(str, ex){
     substring <- str_match(str, ex)
     substring[, 2] # Second column has capture group
}

# Extract prefix before '_'
proteins.df <- mutate(proteins.df, prefix = helper(Accession, '(\\w+)_.*'))
```

```{r }
# How many missing entries?
sum(is.na(proteins.df$prefix))
```

```{r }
# Extract OS from Description column
proteins.df <- mutate(proteins.df, OS = helper(Description, 'OS=(.*)\\sOX='))
```

```{r }
filter(proteins.df, is.na(prefix)) %>% pull(OS) %>% unique() %>% sort()
```

In some cases, the OS is more specific than it should be to match back to database. There is one prefix typo: Piper nigrum should be Pni, not Pne
```{r }
# Manual correction to match database 

proteins.df$OS[proteins.df$OS == 'Vigna radiata var. radiata'] <- 'Vigna radiata'
proteins.df$OS[proteins.df$OS == 'Mentha piperita'] <- 'Mentha x piperita'
proteins.df$prefix[proteins.df$OS == 'Piper nigrum'] <- 'Pni'
```

On first pass through, dimensions after join didn't check out-- turns out there are some prefixes with duplicated entries. Only Pgr and Shi come up here

Pgr: Assigned to both Prunus grayana (japanese bird cherry) and Punica granatum (pomegranate)
Shi: Assigned to both Salvia hispanica (chia) and Scorzonera hispanica (salsify)
Scer: Saccharomyces cerevisiae (yeast) and Secale cereale (rye)
Sso: Salsola soda (saltwort) and Smallanthus sonchifolius (yacon)
Vvi: Vaccinium vitis-idaea (lingonberry) and Vitis vinifera (grape)

```{r }
# Label with prefix unless unavailable; otherwise label by OS

# Join by prefix
join.prefix <- 
     proteins.df %>% 
     # Remove rows without a prefix label
     filter(!is.na(prefix)) %>% 
     # Remove any duplicated prefixes based on initial results
     filter(!(prefix %in% c('Pgr', 'Shi', 'Scer', 'Sso', 'Vvi'))) %>%
     left_join(select(db, scientific_name:category, `PreFix Used`), 
               by = c('prefix' = 'PreFix Used'))

# How many should there be?
proteins.df %>% 
     # Get missed rows in last join
     filter(!is.na(prefix)) %>% 
     # Remove any duplicated prefixes based on initial results
     filter(!(prefix %in% c('Pgr', 'Shi', 'Scer', 'Sso', 'Vvi'))) %>% 
     dim()

# How many are there?
dim(join.prefix)
```

```{r }
# Now, find those entries not joined by prefix, and join by OS instead
join.os <- 
     proteins.df %>% 
     # Get missed rows in last join
     filter(is.na(prefix) | prefix %in% c('Pgr', 'Shi', 'Scer', 
                                          'Sso', 'Vvi')) %>% 
     left_join(select(db, scientific_name:category),
               by = c('OS' = 'scientific_name')) %>% 
     rename(scientific_name = OS)

# Check dimensions are appropriate
cat('Combined dimensions of OS and prefix entries:', dim(join.os)[1] + dim(join.prefix)[1], '\n')
cat('Dimensions of input:', dim(proteins.df)[1])
```

Note that these dimensions may work even with some common name and category entries being empty if the food wasn't in the reference (think this is happening most commonly for fish queried at the family level, and returned at the species level).  

```{r }
# Bind together OS- and prefix-based joins to return to the full dataset

# Drop prefix columns 
join.prefix <- select(join.prefix, -c(prefix, OS))
join.os <- select(join.os, -prefix)

# Check all columns the same
all(names(join.prefix) == names(join.os))

# Join
proteins.df <- bind_rows(join.os, join.prefix)
dim(proteins.df) # How many entries?
any(is.na(proteins.df$scientific_name)) # Any missing entries?
```

### Format as phyloseq object

#### Sample data

```{r }
samdf <-
     proteins.df %>%
     mutate(sample = paste(subj, date, sep = '_')) %>%
     select(subj, date, sample) %>%
     distinct() %>% # Remove duplicated rows
     column_to_rownames(var = 'sample')
```

#### OTU table

```{r }
psm.counts.wide <-
     proteins.df %>%
     mutate(sample = paste(subj, date, sep = '_')) %>% # Create unique label
     # Need to group & summarize, because may be multiple peptides/food
     group_by(sample, scientific_name) %>%
     summarize(abundance = sum(`# PSMs`)) %>%
     pivot_wider(names_from = scientific_name,
                 values_from = abundance, # Total # PSMs
                 values_fill = 0) %>% # If no entry, log as 0
     column_to_rownames(var = 'sample')
```

#### Taxonomy table

Regardless of whether I go on to use taxids as names, I do need to query to build the taxonomy table for the phyloseq object.
```{r }
binomial.only <-
     proteins.df %>%
     select(scientific_name) %>%
     distinct()

taxids <- taxa::lookup_tax_data(binomial.only,
                                type = 'taxon_name',
                                column = 'scientific_name',
                                database = 'ncbi')
```

What wasn't found?
```{r }
result <- taxids$data$query_data
result$scientific_name[result$taxon_id == 'unknown']
```

Get taxonomy
```{r }
taxtab.protein <-
     taxa::taxonomy_table(taxids,
                          use_ranks = c('superkingdom', 'kingdom', 'phylum', 
                                        'class', 'superorder', 
                                        'order', 'superfamily', 
                                        'family', 'subfamily', 
                                        'genus', 'species', 
                                        'subspecies', 'varietas'),
                          add_id_col = TRUE)
```

Note that not all taxids are terminally listed here:
```{r }
dim(taxtab.protein)[1]
length(unique(taxids$data$query_data$taxon_id))
```

This is because some are internal nodes. Manually add their taxonomy too:

```{r }
add <- setdiff(unique(taxids$data$query_data$taxon_id), taxtab.protein$taxon_id)

# Manually inspect
taxids$data$query_data %>%
     filter(taxon_id %in% add) %>% View()

# Write full table, subset these columns out
# write_csv(taxtab.protein,
#           here('data', 'processed',
#                '20210727_Internal taxonomy table nodes.csv'))

add.rows <-
     here('data', 'processed', 
          # '20210408_Internal taxonomy table nodes.csv') %>% # Analysis v2
          '20210727_Internal taxonomy table nodes.csv') %>% # Analysis v3
     read_csv(col_types = cols(.default = 'c'))
```

```{r }
# Bind together
taxtab.protein <-
        taxtab.protein %>%
        bind_rows(add.rows) %>%
        as.data.frame() # This is required in order for lowest level step to work-- so weird-- the code below doesn't seem to work on a tibble
```

Add lowest level name as row name

```{r }
# This gets the right-most, non-NA values
lowest.index <- max.col(!is.na(taxtab.protein), 'last')

# Make row-column pairs to pull and add to taxonomy
taxtab.protein$lowest.level <- taxtab.protein[cbind(seq_along(lowest.index),
                                            lowest.index)]

# Now drop taxid, and convert terminal name to row name
taxtab.protein <-
        taxtab.protein %>%
        select(-taxon_id) %>%
        column_to_rownames(var = 'lowest.level')
```

```{r }
# Check everything matches
setdiff(names(psm.counts.wide), row.names(taxtab.protein))
setdiff(row.names(taxtab.protein), names(psm.counts.wide))
```

```{r }
# Make phyloseq object
ps.protein <- phyloseq(otu_table(psm.counts.wide, taxa_are_rows = FALSE),
                       sample_data(samdf),
                       tax_table(as.matrix(taxtab.protein)))

ps.protein

# saveRDS(ps.protein, 
#         here('data', 'processed', 'phyloseq', '20210727_ps_mp.rds'))
```

## Metaproteomic phyloseq

```{r}
ps.protein <- readRDS(here('data', 'processed', 'phyloseq',
                           '20210408_ps_mp.rds'))
ps.protein
```

## DFC menu data phyloseq

```{r}
ps.menu <- readRDS(here('data', 'processed', 'phyloseq',
                        '20210220_ps_menu.rds'))
ps.menu
```

## Metabarcoding phyloseqs

### trnL

```{r}
# Made in combined MiniSeq notebook in DFC project folder
ps.trnL <- 
     readRDS(here('data', 'processed', 'phyloseq',
                  '20210409_ps_trnL.rds')) 
ps.trnL
```

```{r}
# Subset to only those taxa identified to some position in the plant phylogeny
unlabeled <- 
     data.frame(ps.trnL@tax_table) %>% 
     filter(is.na(superkingdom)) %>% 
     row.names()

asvtab.trnL <- ps.trnL@otu_table

cat('Percent of reads not assigned to a plant taxon:', 
    sum(asvtab.trnL[, unlabeled])/sum(asvtab.trnL) * 100)

ps.trnL <- subset_taxa(ps.trnL, !is.na(superkingdom))
```

```{r}
# Rename samples by subject_date for compatibility
sample_names(ps.trnL) <- paste(sample_data(ps.trnL)$subj,
                               sample_data(ps.trnL)$date, sep = '_')
```

### 12SV5

```{r}
ps.12SV5 <- readRDS(here('data', 'processed', 'phyloseq',
                         '20210409_ps_12SV5.rds'))

ps.12SV5
```

```{r}
# Remove unblocked samples and controls
# (Note that DFC42 is the extraction blank)
ps.12SV5 <- 
     ps.12SV5 %>% 
     subset_samples(blocking == 'b' & !is.na(subj))

ps.12SV5
```

```{r}
# Remove human reads
taxtab.12SV5 <- data.frame(ps.12SV5@tax_table)
asv.human <- 
     taxtab.12SV5 %>%
     filter(genus == 'Homo') %>% 
     row.names()

ps.12SV5 <- prune_taxa(!(taxa_names(ps.12SV5) %in% asv.human),
                       ps.12SV5)
```

```{r}
# Subset to only those taxa identified to some position in the animal phylogeny
unlabeled <- 
     data.frame(ps.12SV5@tax_table) %>% 
     filter(is.na(superkingdom)) %>% 
     row.names()

asvtab.12SV5 <- ps.12SV5@otu_table

cat('Percent of reads not assigned to an animal taxon:', 
    sum(asvtab.12SV5[, unlabeled])/sum(asvtab.12SV5) * 100)

ps.12SV5 <- subset_taxa(ps.12SV5, !is.na(superkingdom))
```

```{r}
# Rename samples by subject_date for compatibility
sample_names(ps.12SV5) <- paste(sample_data(ps.12SV5)$subj,
                                sample_data(ps.12SV5)$date, sep = '_')
```

## Join

```{r}
# Having trouble merging because of character/date formats, need to sort this out but hold off for now
```

# Exploratory comparison

## Per-sample details

Overall view:
```{r echo = FALSE}
# How many food taxa consumed daily (menu)?
melt.menu <- psmelt(ps.menu)
counts.menu <- 
     melt.menu %>% 
     filter(Abundance > 0) %>% 
     group_by(ID, date, kingdom) %>% 
     count(name = 'menu_taxa')
```

```{r echo = FALSE}
# How many food taxa detected daily (metaproteomics)?
melt.protein <- psmelt(ps.protein)
counts.protein <- 
     melt.protein %>% 
     filter(Abundance > 4) %>% 
     group_by(subj, date, kingdom) %>% 
     count(name = 'protein_taxa')
```

```{r}
# How many food taxa detected daily (metabarcoding)?
melt.trnL <- psmelt(ps.trnL)
counts.trnL <- 
     melt.trnL %>% 
     filter(Abundance > 0) %>% 
     group_by(subj, date, kingdom) %>% 
     count(name = 'dna_taxa')

melt.12SV5 <- psmelt(ps.12SV5)
counts.12SV5 <- 
     melt.12SV5 %>% 
     filter(Abundance > 0) %>% 
     group_by(subj, date, kingdom) %>% 
     count(name = 'dna_taxa')

# Join together
counts.mb <- full_join(counts.trnL, counts.12SV5)
rm(counts.trnL, counts.12SV5)
```

```{r}
# Combine
counts <- 
     counts.menu %>% 
     left_join(counts.protein, by = c('ID' = 'subj', 'date', 'kingdom')) %>% 
     left_join(counts.mb, by = c('ID' = 'subj', 'date', 'kingdom'))
     

# Long version for plotting
counts.long <- pivot_longer(counts, 
                            cols = ends_with('taxa'),
                            names_to = 'dataset',
                            values_to = 'value')

# Update names for plotting
counts.long$dataset <- factor(counts.long$dataset, 
                              levels = c('menu_taxa', 'protein_taxa',
                                         'dna_taxa'), 
                              labels = c('Recorded menu', 'Metaproteomics',
                                         'Metabarcoding'))
```

```{r}
# Now do the same, but for only the samples in common between all 3 datasets
counts.shared <- 
     counts %>% 
     filter(((!is.na(menu_taxa) & !is.na(protein_taxa) & !is.na(dna_taxa))))

# Long version for plotting
counts.shared.long <- pivot_longer(counts.shared , 
                                   cols = ends_with('taxa'),
                                   names_to = 'dataset',
                                   values_to = 'value')

# Update names for plotting
counts.shared.long$dataset <- factor(counts.shared.long$dataset, 
                                     levels = c('menu_taxa', 
                                                'protein_taxa',
                                                'dna_taxa'), 
                                     labels = c('Recorded menu',
                                                'Metaproteomics',
                                                'Metabarcoding'))
```

```{r}
ggplot(counts.long, aes(x = kingdom, y = value, fill = dataset)) +
     geom_boxplot() +
     labs(title = 'Number of food taxa identified by source',
          subtitle = '>4 PSMs per taxa filter',
          y = 'Number of taxa', fill = 'Source') +
     theme_bw() +
     theme(axis.title.x = element_blank())

plotID <- paste(Sys.Date(), as.character(sample(000:999,1)), sep=".")
# ggsave(here('results', paste0(plotID, '_Number of food taxa by source, >4 PSM filter.pdf')),
#        height = 4)
```

```{r}
ggplot(counts.shared.long, aes(x = kingdom, y = value, fill = dataset)) +
     geom_boxplot() +
     labs(title = 'Number of food taxa identified by source',
          subtitle = '>4 PSMs per taxa filter',
          y = 'Number of taxa', fill = 'Source') +
     theme_bw() +
     theme(axis.title.x = element_blank())

plotID <- paste(Sys.Date(), as.character(sample(000:999,1)), sep=".")
# ggsave(here('results', paste0(plotID, '_Number of food taxa by source, shared samples only.pdf')),
# height = 4, width = 4)
```

```{r echo = FALSE}
t.test(counts$menu_taxa, counts$protein_taxa)
```

Patterns of recorded foods by day of week: 

```{r echo = FALSE}
counts.long %>% 
     group_by(ID, date, dataset) %>% 
     summarize(value = sum(value, na.rm = TRUE)) %>% 
     filter(dataset == 'Recorded menu') %>% 
     ggplot(aes(x = date, y = value)) +
     geom_point(aes(color = dataset)) +
     facet_wrap(~ ID, nrow = 4, scales = 'free_x') + 
     labs(x = 'Date', y = 'Number of taxa') +
     theme_bw() +
     theme(axis.title.x = element_blank(),
           legend.title = element_blank(),
           legend.position = 'bottom')

plotID <- paste(Sys.Date(), as.character(sample(000:999,1)), sep=".")
# ggsave(here('results', 
#             paste0(plotID, 
#                    '_Number of food taxa in menu by day.pdf')),
#        height = 7, width = 4)
```

## Metaproteomics x menu

### Apply PSM filter to phyloseq object

```{r}
## Need to be careful-- this would only apply to the following code chunk, later on can impose a threshold without altering the phyloseq object
# otutab <- otu_table(ps.protein)@.Data
# otutab[otutab <= 4] = 0
# 
# # Replace in phyloseq object
# ps.protein <- phyloseq(otu_table(otutab, taxa_are_rows = FALSE),
#                        sample_data(ps.protein),
#                        tax_table(ps.protein))
# 
# # Now remove any taxa with zero counts
# ps.protein <- prune_taxa(taxa_sums(ps.protein) > 0,
#                          ps.protein)
```

### Overall dataset

```{r}
taxtab.protein <- tax_table(ps.protein)@.Data
taxtab.menu <- tax_table(ps.menu)@.Data
```

What species are shared between metaproteomic and menu datasets (regardless of menu date?)
```{r}
intersect(row.names(taxtab.protein), row.names(taxtab.menu))
```

What species are in metaproteomic dataset that are never recorded in menu data (on any day?)

This comparison is a bit tricky because some food taxa names aren't fully specified in our transcription of the menu.  Examples:
* 

```{r}
fp <- setdiff(row.names(taxtab.protein), row.names(taxtab.menu))
fp
```

What kingdom do these originate from?  Do we have more false-positive animals than plants, for example?

```{r}
# Pull these rows from the taxonomy table
fp.taxonomy <- taxtab.protein[fp, ]
fp.taxonomy %>% 
     data.frame() %>% 
     group_by(phylum) %>% 
     count() %>% 
     arrange(desc(n))
```
Interesting-- at least in this high-level view, it's mostly plants. 

Try visualizing with metacoder?

### Pairing with 1-2 days prior intake

For this broadest level comparison, let's look only at the two days prior to sampling.

```{r echo = FALSE}
# Pull sample data for stool samples
samdf.protein <- 
     sample_data(ps.protein) %>% 
     as('data.frame') %>% 
     rownames_to_column(var = 'row')

# Label each stool sample with its two preceding days
for (delta in 1:2){
     varname <- paste0('delta', delta)
     samdf.protein <- mutate(samdf.protein, 
                             !!varname := paste(subj, date - delta, 
                                                sep = '_'))
}

# Replace in phyloseq object
sample_data(ps.protein) <- column_to_rownames(samdf.protein, var = 'row')
```

```{r}
# Can't use merge_samples on phyloseq here because some samples make up >1 merge

# Do manually on ASV table
asvtab.menu <- otu_table(ps.menu)@.Data
asvtab.menu.12 <- data.frame()

for (sample in seq(dim(samdf.protein)[1])){
     # Pull menu day -1
     one.before <- asvtab.menu[samdf.protein$delta1[sample], ]
     # Pull menu day -2
     two.before <- asvtab.menu[samdf.protein$delta2[sample], ]
     # Merge and place in new, aggregated OTU table
     asvtab.menu.12 <- rbind(asvtab.menu.12,
                             one.before + two.before)
     # Update food names (only has to be done once)
     if (sample == 1){names(asvtab.menu.12) <- names(one.before + two.before)}
     # Update sample name
     row.names(asvtab.menu.12)[sample] <- samdf.protein$row[sample]
}

# Now rebuild a subsetted phyloseq object
ps.menu.12 <- phyloseq(otu_table(asvtab.menu.12, taxa_are_rows = FALSE),
                       sample_data(ps.protein), # Now this matches
                       tax_table(ps.menu)) # Menu-specific taxonomy

# Remove any taxa that aren't present any longer
ps.menu.12 <- prune_taxa(taxa_sums(ps.menu.12) > 0, ps.menu.12)
ps.menu.12
```

There are `r ntaxa(ps.menu.12)` recorded in the menu in the 2 days prior to each sample, and `r ntaxa(ps.protein)` detected by metaproteomics.

Overlap between the two? Good-- this is pretty similar in overall number to the full dataset (not filtering by menu day-- that gave 69 intersecting taxon names). 

A bit tricky because not all options are compatibly named.  Try grouping to genus level to smooth over at least some of this.

```{r}
ps.menu.12 <- tax_glom(ps.menu.12, 'genus')
taxa_names(ps.menu.12) <- tax_table(ps.menu.12)[, 'genus']

ps.protein <- tax_glom(ps.protein, 'genus')
taxa_names(ps.protein) <- tax_table(ps.protein)[, 'genus']
```

### Paired samples, per-food

```{r}
# Extract OTU tables
asvtab.protein <- otu_table(ps.protein)@.Data
asvtab.menu.12 <- otu_table(ps.menu.12)@.Data

# Synchronize names (not all genera in common between the two)
dim(asvtab.protein)
dim(asvtab.menu.12)
length(union(colnames(asvtab.menu.12), colnames(asvtab.protein)))
```

```{r}
# Helper function to pad out columns
pad_columns <- function(x, y, fill = 0){
     # Takes two matrices and synchronizes columns across them, filling added 
     # cols with a set value
     # Returns a list of the two updated matrices
     
     # Find missing columns in both matrices
     missing.x <- setdiff(colnames(y), colnames(x))
     missing.y <- setdiff(colnames(x), colnames(y))
     
     # Pad out columns of x
     fill.x <- matrix(fill, 
                      nrow = dim(x)[1],
                      ncol = length(missing.x))
     colnames(fill.x) <- missing.x 
     x <- cbind(x, fill.x)
     
     # Pad out columns of y
     fill.y <- matrix(fill, 
                      nrow = dim(y)[1],
                      ncol = length(missing.y))
     colnames(fill.y) <- missing.y
     y <- cbind(y, fill.y)
     
     # Arrange the columns so they appear in identical order
     u <- sort(union(colnames(x), colnames(y)))
     x <- x[, u]
     y <- y[, u]
     
     list(x, y)
}
```

```{r}
padded <- pad_columns(asvtab.protein, asvtab.menu.12)
asvtab.protein <- padded[[1]]
asvtab.menu.12 <- padded[[2]]

rm(padded)
```

```{r}
# Confirm row and column names are equal before proceeding
all(row.names(asvtab.protein) == row.names(asvtab.menu.12))
all(colnames(asvtab.protein) == colnames(asvtab.menu.12))
```

```{r}
# Label predictions 
protein.pos <- asvtab.protein > 4
menu.pos <- asvtab.menu.12 > 0

tp <- protein.pos & menu.pos
tn <- !protein.pos & !menu.pos
fp <- protein.pos & !menu.pos
fn <- !protein.pos & menu.pos

pred <- bind_rows(colSums(tp),
                  colSums(tn),
                  colSums(fp),
                  colSums(fn))

pred$prediction <- c('tp', 'tn', 'fp', 'fn')

pred <- select(pred, prediction, everything())
```

```{r}
# Reformat to long for visualization
pred.long <- pivot_longer(pred,
                          cols = -prediction,
                          names_to = 'taxon',
                          values_to = 'count')

# Factor data for visualization
# Calculate F-measure to be used downstream
pred.summary <- 
     pred.long %>% 
     pivot_wider(names_from = prediction, values_from = count) %>% 
     mutate(recall = tp/(tp + fn),
            precision = tp/(tp + fp),
            f_measure = (2 * recall * precision)/(recall + precision)) %>% 
     arrange(desc(f_measure), fn, fp)

# Assign label for faceting plot
# Done by manually inspecting pred.summary
breaks <- c(rep(1, 30), rep(2, 33), rep(3, 37), rep(4, 33))
pred.summary$facet <- breaks

pred.long <- 
     pred.summary %>% 
     select(taxon, facet) %>% 
     right_join(pred.long) %>% 
     select(facet, taxon, everything())

pred.long <- 
     pred.long %>% 
     mutate(taxon = factor(taxon, levels = pred.summary$taxon),
            prediction = factor(prediction, levels = c('tp', 'tn', 'fp', 'fn'),
                                labels = c('True positive', 'True negative',
                                           'False positive', 'False negative')))
```

```{r}
# Save for comparison to metabarcoding data
saveRDS(pred.long,
        here('data', 'processed', 'performance-metrics', 
             'Metaproteomic v. menu predictions by food, 1-2d prior, >4 counts per taxon filter.rds'))
```


```{r}
ggplot(pred.long, aes(x = taxon, y = count, fill = prediction)) +
     geom_bar(position = 'stack', stat = 'identity') +
     scale_fill_manual(values = c('#1A9641','#A6D96A', # TP, TN
                                  '#D7191C', '#FDAE61')) + # FP, FN
     facet_wrap(~facet, nrow = 4, scale = 'free_x') +
     theme_bw() +
     theme(axis.text.x = element_text(angle = 45, hjust = 1),
           axis.text.y = element_blank(),
           axis.title = element_blank(),
           legend.position = 'top',
           legend.title = element_blank(), 
           plot.margin = margin(0, 0.5, 0.5, 0.5, 'in'),
           strip.text.x = element_blank()) 

plotID <- paste(Sys.Date(), as.character(sample(000:999,1)), sep=".")

ggsave(here('results', paste0(plotID, '_By-food predictions compared to menu, >4 PSMs per taxon filter.pdf')),
       height = 8, width = 8)
# 2021-02-22.677: First pass
# 2021-03-10.682: Re-colored
# 2021-04-09.985: Database v2, no PSM filter
# 2021-04-09.831: Database v2, >4 PSMs/taxon/sample filter
```

## Metaproteomics x metabarcoding 

### Paired samples, per-food

```{r}
# Extract OTU tables
asvtab.protein <- otu_table(ps.protein)@.Data
asvtab.trnL <- otu_table(ps.trnL)@.Data 
asvtab.12SV5 <- otu_table(ps.12SV5)@.Data 

# Combine metabarcoding (have to do here because I'm having trouble with merge_phyloseq, above)
shared.mb <- intersect(row.names(asvtab.trnL), row.names(asvtab.12SV5))
asvtab.mb <- cbind(asvtab.trnL[shared.mb,],
                   asvtab.12SV5[shared.mb,])

# Synchronize names (not all genera in common between the two)
dim(asvtab.protein)
dim(asvtab.menu.12)
length(union(colnames(asvtab.menu.12), colnames(asvtab.protein)))
```

```{r}
# Helper function to pad out columns
pad_columns <- function(x, y, fill = 0){
     # Takes two matrices and synchronizes columns across them, filling added 
     # cols with a set value
     # Returns a list of the two updated matrices
     
     # Find missing columns in both matrices
     missing.x <- setdiff(colnames(y), colnames(x))
     missing.y <- setdiff(colnames(x), colnames(y))
     
     # Pad out columns of x
     fill.x <- matrix(fill, 
                      nrow = dim(x)[1],
                      ncol = length(missing.x))
     colnames(fill.x) <- missing.x 
     x <- cbind(x, fill.x)
     
     # Pad out columns of y
     fill.y <- matrix(fill, 
                      nrow = dim(y)[1],
                      ncol = length(missing.y))
     colnames(fill.y) <- missing.y
     y <- cbind(y, fill.y)
     
     # Arrange the columns so they appear in identical order
     u <- sort(union(colnames(x), colnames(y)))
     x <- x[, u]
     y <- y[, u]
     
     list(x, y)
}
```

```{r}
padded <- pad_columns(asvtab.protein, asvtab.menu.12)
asvtab.protein <- padded[[1]]
asvtab.menu.12 <- padded[[2]]

rm(padded)
```

```{r}
# Confirm row and column names are equal before proceeding
all(row.names(asvtab.protein) == row.names(asvtab.menu.12))
all(colnames(asvtab.protein) == colnames(asvtab.menu.12))
```

```{r}
# Label predictions 
protein.pos <- asvtab.protein > 4
menu.pos <- asvtab.menu.12 > 0

tp <- protein.pos & menu.pos
tn <- !protein.pos & !menu.pos
fp <- protein.pos & !menu.pos
fn <- !protein.pos & menu.pos

pred <- bind_rows(colSums(tp),
                  colSums(tn),
                  colSums(fp),
                  colSums(fn))

pred$prediction <- c('tp', 'tn', 'fp', 'fn')

pred <- select(pred, prediction, everything())
```

```{r}
# Reformat to long for visualization
pred.long <- pivot_longer(pred,
                          cols = -prediction,
                          names_to = 'taxon',
                          values_to = 'count')

# Factor data for visualization
# Calculate F-measure to be used downstream
pred.summary <- 
     pred.long %>% 
     pivot_wider(names_from = prediction, values_from = count) %>% 
     mutate(recall = tp/(tp + fn),
            precision = tp/(tp + fp),
            f_measure = (2 * recall * precision)/(recall + precision)) %>% 
     arrange(desc(f_measure), fn, fp)

# Assign label for faceting plot
# Done by manually inspecting pred.summary
breaks <- c(rep(1, 30), rep(2, 33), rep(3, 37), rep(4, 33))
pred.summary$facet <- breaks

pred.long <- 
     pred.summary %>% 
     select(taxon, facet) %>% 
     right_join(pred.long) %>% 
     select(facet, taxon, everything())

pred.long <- 
     pred.long %>% 
     mutate(taxon = factor(taxon, levels = pred.summary$taxon),
            prediction = factor(prediction, levels = c('tp', 'tn', 'fp', 'fn'),
                                labels = c('True positive', 'True negative',
                                           'False positive', 'False negative')))
```

```{r}
ggplot(pred.long, aes(x = taxon, y = count, fill = prediction)) +
     geom_bar(position = 'stack', stat = 'identity') +
     scale_fill_manual(values = c('#1A9641','#A6D96A', # TP, TN
                                  '#D7191C', '#FDAE61')) + # FP, FN
     facet_wrap(~facet, nrow = 4, scale = 'free_x') +
     theme_bw() +
     theme(axis.text.x = element_text(angle = 45, hjust = 1),
           axis.text.y = element_blank(),
           axis.title = element_blank(),
           legend.position = 'top',
           legend.title = element_blank(), 
           plot.margin = margin(0, 0.5, 0.5, 0.5, 'in'),
           strip.text.x = element_blank()) 

plotID <- paste(Sys.Date(), as.character(sample(000:999,1)), sep=".")

ggsave(here('results', paste0(plotID, '_By-food predictions compared to menu, >4 PSMs per taxon filter.pdf')),
       height = 8, width = 8)
# 2021-02-22.677: First pass
# 2021-03-10.682: Re-colored
# 2021-04-09.985: Database v2, no PSM filter
# 2021-04-09.831: Database v2, >4 PSMs/taxon/sample filter
```



