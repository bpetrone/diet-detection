---
title: "Kleiner lab database testing"
output:
  html_document:
    df_print: paged
---

Pass stuff ranked by sens, specificity

Here we are evaluating the preliminary data shared by the Kleiner lab at NCSU to determine if their metaproteomic database should be adjusted (e.g. filtering out homologs to human proteins, other ideas?) before continuing with analysis of the DFC samples.

# R setup

```{r setup, include=FALSE, echo=FALSE}
require("knitr")
opts_knit$set(root.dir = file.path(getwd(), '..'))
```

```{r libraries, echo=FALSE}
library(here) 
library(phyloseq) 
library(readxl) # For parsing Excel files
library(tidyverse) 
```

# Read in files

## Current reference database

```{r eval = FALSE, echo = FALSE}
# Read in the first sheet of the file using read_excel function
db <- read_excel(here('data', 'processed', 'DietaryDB_ForDavidLab.xlsx'), 
                 sheet = 1, 
                 n_max = 547) # Exclude annotations at end of file
head(db)
```
```{r eval = FALSE, echo = FALSE}
# Manual updates
# Specify scientific name for tilapia
db$scientific_name[db$scientific_name == 'Tilapia'] <- 'Oreochromis niloticus'
# Correct misspelling for mallard duck
db$scientific_name[db$scientific_name == 'Anas platyrhynchose'] <- 'Anas platyrhynchos'
# Switch var. to subsp. for durum
db$scientific_name[db$scientific_name == 'Triticum turgidum var. durum'] <- 'Triticum turgidum subsp. durum'
# Correct spelling of water buffalo
db$scientific_name[db$scientific_name == 'Bubalis bubalis'] <- 'Bubalus bubalis'
# Think something weird about formatting of "x" in Musa x paradisiaca, not being recognized
db$scientific_name[db$common_name == 'plantain'] <- 'Musa x paradisiaca'
# Remove zante currant, which is redundant with V. vinifera
db <- filter(db, common_name != 'zante currant')
``` 
## Participant metaproteomic data

### Combine files

```{r eval = FALSE, echo = FALSE}
# List files
fs <- list.files(here('data', 'raw',
                     'Proteins_IndividualResultFiles_RealisticFoodsWithMicrobiota'),
                  pattern = ".xlsx", full.names = T)

# Read and synchronize names
dfs <- 
     lapply(fs, read_excel) %>% 
     # Rename "Found in sample" column so it's the same for each sample
     lapply(., 
            function(x){
                 # Update name
                 names(x)[grep('Found in Sample: *', names(x))] <- 'Found in Sample'
                 # Return original object
                 x
                 }
            )

# Bind together
names(dfs) <- basename(fs)
proteins.df <- bind_rows(dfs, .id = 'id')
rm(fs, dfs)
```

### Clean
```{r eval = FALSE, echo = FALSE}
proteins.df <- 
     proteins.df %>% 
     # Clean up ID column
     separate(col = 'id', into = c('id', 'subj', 'date'),
                        sep = '_', remove = TRUE, extra = 'drop') %>% 
     # Convert date to Date type
     mutate(date = as.Date(date, format = '%d%b%y'))
```

```{r eval = FALSE, echo = FALSE}
head(proteins.df)
```
```{r eval = FALSE, echo = FALSE}
dim(proteins.df)
```

### Filter 

```{r eval = FALSE, echo = FALSE}
# Filter to only food-derived proteins (this removes majority)
proteins.df <- 
     proteins.df %>% 
     filter(!grepl('Human_*', Accession)) %>% # Remove human proteins
     filter(!grepl('Microbiota_*', Accession)) # Remove microbiota proteins

dim(proteins.df)
```

```{r eval = FALSE, echo = FALSE}
# Remove proteins labeled as not found in sample
# Very low abundance (though non-zero counts), only one from wheat
proteins.df <- filter(proteins.df, `Found in Sample` != 'Not Found')
dim(proteins.df)
```

### Relabel with food species

Using a combination of OS (embedded in Description column) and prefix assigned in database.

```{r eval = FALSE, echo = FALSE}
head(proteins.df$Description)
cat('\n')
head(proteins.df$Accession)
```

```{r eval = FALSE, echo = FALSE}
# Separate prefix into its own column

# Helper function for use inside mutate
helper <- function(str, ex){
     substring <- str_match(str, ex)
     substring[, 2] # Second column has capture group
}

# Extract prefix before '_'
proteins.df <- mutate(proteins.df, prefix = helper(Accession, '(\\w+)_.*'))
```

```{r eval = FALSE, echo = FALSE}
# How many missing entries?
sum(is.na(proteins.df$prefix))
```

```{r eval = FALSE, echo = FALSE}
# Extract OS from Description column
proteins.df <- mutate(proteins.df, OS = helper(Description, 'OS=(.*)\\sOX='))
```

```{r eval = FALSE, echo = FALSE}
filter(proteins.df, is.na(prefix)) %>% pull(OS) %>% unique()
```

In some cases, the OS is more specific than it should be to match back to database. 
```{r eval = FALSE, echo = FALSE}
# Manual correction to match database (V.radiata, M. piperita, O. sativa, B. vulgaris)

proteins.df$OS[proteins.df$OS == 'Vigna radiata var. radiata'] <- 'Vigna radiata'
proteins.df$OS[proteins.df$OS == 'Mentha piperita'] <- 'Mentha x piperita'

# P. nigrum prefix labeled as Pne, should be Pni by database

proteins.df$prefix[proteins.df$prefix == 'Pne'] <- 'Pni'
```

```{r eval = FALSE, echo = FALSE}
# Label with prefix unless unavailable; otherwise label by OS

# Join by prefix
join.prefix <- 
     proteins.df %>% 
     # Remove rows without a prefix label
     filter(!is.na(prefix)) %>% 
     # Remove any duplicated prefixes based on initial results
     filter(!(prefix %in% c('Pgr', 'Shi', 'Scer', 'Sso', 'Vvi'))) %>%  
     left_join(select(db, scientific_name:category, `PreFix Used`), 
               by = c('prefix' = 'PreFix Used'))

# How many should there be?
proteins.df %>% 
     # Get missed rows in last join
     filter(!is.na(prefix)) %>% 
     # Remove any duplicated prefixes based on initial results
     filter(!(prefix %in% c('Pgr', 'Shi', 'Scer', 'Sso', 'Vvi'))) %>% 
     dim

# How many are there?
dim(join.prefix)
```

On first pass through, these dimensions didn't check out-- turns out there are some prefixes with duplicated entries. Only Pgr and Shi come up here

Pgr: Assigned to both Prunus grayana (japanese bird cherry) and Punica granatum (pomegranate)
Shi: Assigned to both Salvia hispanica (chia) and Scorzonera hispanica (salsify)
Scer: Saccharomyces cerevisiae (yeast) and Secale cereale (rye)
Sso: Salsola soda (saltwort) and Smallanthus sonchifolius (yacon)
Vvi: Vaccinium vitis-idaea (lingonberry) and Vitis vinifera (grape)

```{r eval = FALSE, echo = FALSE}
# Now, find those entries not joined by prefix, and join by OS instead
join.os <- 
     proteins.df %>% 
     # Get missed rows in last join
     filter(is.na(prefix) | prefix %in% c('Pgr', 'Shi', 'Scer', 
                                          'Sso', 'Vvi')) %>% 
     left_join(select(db, scientific_name:category),
               by = c('OS' = 'scientific_name')) %>% 
     rename(scientific_name = OS)

# Check dimensions are appropriate
cat('Combined dimensions of OS and prefix entries:', dim(join.os)[1] + dim(join.prefix)[1], '\n')
cat('Dimensions of input:', dim(proteins.df)[1])
```

```{r eval = FALSE, echo = FALSE}
# Bind together OS- and prefix-based joins to return to the full dataset

# Drop prefix columns 
join.prefix <- select(join.prefix, -c(prefix, OS))
join.os <- select(join.os, -prefix)

# Check all columns the same
all(names(join.prefix) == names(join.os))

# Join
proteins.df <- bind_rows(join.os, join.prefix)
dim(proteins.df) # How many entries?
any(is.na(proteins.df$scientific_name)) # Any missing entries?
```

### Format as phyloseq object

#### Sample data

```{r eval = FALSE, echo = FALSE}
samdf <-
     proteins.df %>%
     mutate(sample = paste(subj, date, sep = '_')) %>%
     select(subj, date, sample) %>%
     distinct() %>% # Remove duplicated rows
     column_to_rownames(var = 'sample')
```

#### OTU table

```{r eval = FALSE, echo = FALSE}
psm.counts.wide <-
     proteins.df %>%
     mutate(sample = paste(subj, date, sep = '_')) %>% # Create unique label
     # Need to group & summarize, because may be multiple peptides/food
     group_by(sample, scientific_name) %>%
     summarize(abundance = sum(`# PSMs`)) %>%
     pivot_wider(names_from = scientific_name,
                 values_from = abundance, # Total # PSMs
                 values_fill = 0) %>% # If no entry, log as 0
     column_to_rownames(var = 'sample')
```

#### Taxonomy table

Regardless of whether I go on to use taxids as names, I do need to query to build the taxonomy table for the phyloseq object.
```{r eval = FALSE, echo = FALSE}
binomial.only <-
     proteins.df %>%
     select(scientific_name) %>%
     distinct()

taxids <- taxa::lookup_tax_data(binomial.only,
                                type = 'taxon_name',
                                column = 'scientific_name',
                                database = 'ncbi')
```

What wasn't found?
```{r eval = FALSE, echo = FALSE}
result <- taxids$data$query_data
result$scientific_name[result$taxon_id == 'unknown']
```

Get taxonomy
```{r eval = FALSE, echo = FALSE}
taxtab.protein <-
     taxa::taxonomy_table(taxids,
                          use_ranks = c('superkingdom', 'kingdom', 'phylum', 
                                        'class', 'superorder', 
                                        'order', 'superfamily', 
                                        'family', 'genus', 'species', 
                                        'subspecies', 'varietas'),
                          add_id_col = TRUE)
```

Note that not all taxids are terminally listed here:
```{r eval = FALSE, echo = FALSE}
dim(taxtab.protein)[1]
length(unique(taxids$data$query_data$taxon_id))
```

This is because some are internal nodes. Manually add their taxonomy too:

```{r eval = FALSE, echo = FALSE}
add <- setdiff(unique(taxids$data$query_data$taxon_id), taxtab.protein$taxon_id)

# Manually inspect
# taxids$data$query_data %>%
#      filter(taxon_id %in% add) %>% View()

# Write full table, subset these columns out
# write_csv(taxtab.protein,
#           here('data', 'processed',
#                '20210208_Internal taxonomy table nodes.csv'))

add.rows <-
     here('data', 'processed', 
          '20210208_Internal taxonomy table nodes.csv') %>%
     read_csv(col_types = cols(.default = 'c'))
```

```{r eval = FALSE, echo = FALSE}
# Bind together
taxtab.protein <-
        taxtab.protein %>%
        bind_rows(add.rows) %>%
        as.data.frame() # This is required in order for lowest level step to work-- so weird-- the code below doesn't seem to work on a tibble
```

Add lowest level name as row name

```{r eval = FALSE, echo = FALSE}
# This gets the right-most, non-NA values
lowest.index <- max.col(!is.na(taxtab.protein), 'last')

# Make row-column pairs to pull and add to taxonomy
taxtab.protein$lowest.level <- taxtab.protein[cbind(seq_along(lowest.index),
                                            lowest.index)]

# Now drop taxid, and convert terminal name to row name
taxtab.protein <-
        taxtab.protein %>%
        select(-taxon_id) %>%
        column_to_rownames(var = 'lowest.level')
```

```{r eval = FALSE, echo = FALSE}
# Check everything matches
setdiff(names(psm.counts.wide), row.names(taxtab.protein))
setdiff(row.names(taxtab.protein), names(psm.counts.wide))
```

```{r eval = FALSE, echo = FALSE}
# Make phyloseq object
ps.protein <- phyloseq(otu_table(psm.counts.wide, taxa_are_rows = FALSE),
                       sample_data(samdf),
                       tax_table(as.matrix(taxtab.protein)))

ps.protein

# saveRDS(ps.protein, here('data', 'processed', 'phyloseq', '20210212_ps.rds'))
```

## Metaproteomic phyloseq

```{r}
ps.protein <- readRDS(here('data', 'processed', 'phyloseq',
                           '20210212_ps_mp.rds'))
ps.protein
```

## DFC menu data phyloseq

```{r}
ps.menu <- readRDS(here('data', 'processed', 'phyloseq',
                        '20210220_ps_menu.rds'))
ps.menu
```

## Metabarcoding phyloseqs

### trnL

```{r}
# This experiment contained PCRs amplified with an annealing temp of 55 or 63C; filter to only those at 63.
ps.trnL <- 
     readRDS(here('data', 'processed', 'phyloseq',
                        '20200225_ps_trnL.rds')) %>% 
     subset_samples(anneal_t == '63') %>% # Subset to 63C samples
     prune_taxa(taxa_sums(.) > 0, .) %>% # Remove taxa now with 0 reads
     subset_taxa(!is.na(superkingdom)) # Remove SVs not identified to a food

ps.trnL
```

```{r}
# Rename samples by subject_date for compatibility
sample_names(ps.trnL) <- paste(sample_data(ps.trnL)$subject,
                               sample_data(ps.trnL)$date, sep = '_')
```

### 12SV5

```{r}
ps.12SV5 <- readRDS(here('data', 'processed', 'phyloseq',
                         '20201014_ps_12SV5.rds'))

ps.12SV5
```

# Exploratory comparison

## Per-sample details

Overall view:
```{r echo = FALSE}
# How many food taxa consumed daily (menu)?
melt.menu <- psmelt(ps.menu)
counts.menu <- 
     melt.menu %>% 
     filter(Abundance > 0) %>% 
     group_by(ID, date) %>% 
     count(name = 'menu_taxa')
```

```{r echo = FALSE}
# How many food taxa detected daily (metaproteomics)?
melt.protein <- psmelt(ps.protein)
counts.protein <- 
     melt.protein %>% 
     filter(Abundance > 0) %>% 
     group_by(subj, date) %>% 
     count(name = 'protein_taxa')
```

```{r}
# Combine
counts <- left_join(counts.menu, counts.protein,
                    by = c('ID' = 'subj', 'date'))

# Long version for plotting
counts.long <- pivot_longer(counts, 
                            cols = ends_with('taxa'),
                            names_to = 'dataset',
                            values_to = 'value')

# Update names for plotting
counts.long$dataset <- factor(counts.long$dataset, 
                              levels = c('menu_taxa', 'protein_taxa'), 
                              labels = c('Recorded menu', 'Metaproteomics'))

head(counts)
```
```{r}
ggplot(counts.long, aes(x = dataset, y = value)) +
     geom_boxplot() +
     labs(title = 'Number of food taxa identified by source',
          y = 'Number of taxa') +
     theme_bw() +
     theme(axis.title.x = element_blank())
```

```{r echo = FALSE}
t.test(counts$menu_taxa, counts$protein_taxa)
```

By subject:

```{r echo = FALSE}
ggplot(counts.long, aes(x = ID, y = value)) +
     geom_boxplot() +
     facet_wrap(~ dataset) + 
     labs(y = 'Number of taxa') +
     theme_bw() +
     theme(axis.title.x = element_blank())
```
By subject and day: 

```{r echo = FALSE}
ggplot(counts.long, aes(x = date, y = value)) +
     geom_point(aes(color = dataset)) +
     facet_wrap(~ ID, nrow = 2, scales = 'free_x') + 
     labs(x = 'Date', y = 'Number of taxa') +
     theme_bw() +
     theme(axis.title.x = element_blank(),
           legend.title = element_blank(),
           legend.position = 'bottom')
```

## Metaproteomics x menu

### Overall dataset

```{r}
taxtab.protein <- tax_table(ps.protein)@.Data
taxtab.menu <- tax_table(ps.menu)@.Data
```

What species are shared between metaproteomic and menu datasets (regardless of menu date?)
```{r}
intersect(row.names(taxtab.protein), row.names(taxtab.menu))
```

What species are in metaproteomic dataset that are never recorded in menu data (on any day?)

This comparison is a bit tricky because some food taxa names aren't fully specified in our transcription of the menu.  Examples:
* 

```{r}
fp <- setdiff(row.names(taxtab.protein), row.names(taxtab.menu))
fp
```

What kingdom do these originate from?  Do we have more false-positive animals than plants, for example?

```{r}
# Pull these rows from the taxonomy table
fp.taxonomy <- taxtab.protein[fp, ]
fp.taxonomy %>% 
     data.frame() %>% 
     group_by(phylum) %>% 
     count() %>% 
     arrange(desc(n))
```
Interesting-- at least in this high-level view, it's mostly plants. 

Try visualizing with metacoder?

### Pairing with 1-2 days prior intake

For this broadest level comparison, let's look only at the two days prior to sampling.

```{r echo = FALSE}
# Pull sample data for stool samples
samdf.protein <- 
     sample_data(ps.protein) %>% 
     as('data.frame') %>% 
     rownames_to_column(var = 'row')

# Label each stool sample with its two preceding days
for (delta in 1:2){
     varname <- paste0('delta', delta)
     samdf.protein <- mutate(samdf.protein, 
                             !!varname := paste(subj, date - delta, 
                                                sep = '_'))
}

# Replace in phyloseq object
sample_data(ps.protein) <- column_to_rownames(samdf.protein, var = 'row')
```

```{r}
# Can't use merge_samples on phyloseq here because some samples make up >1 merge

# Do manually on ASV table
asvtab.menu <- otu_table(ps.menu)@.Data
asvtab.menu.12 <- data.frame()

for (sample in seq(dim(samdf.protein)[1])){
     # Pull menu day -1
     one.before <- asvtab.menu[samdf.protein$delta1[sample], ]
     # Pull menu day -2
     two.before <- asvtab.menu[samdf.protein$delta2[sample], ]
     # Merge and place in new, aggregated OTU table
     asvtab.menu.12 <- rbind(asvtab.menu.12,
                             one.before + two.before)
     # Update food names (only has to be done once)
     if (sample == 1){names(asvtab.menu.12) <- names(one.before + two.before)}
     # Update sample name
     row.names(asvtab.menu.12)[sample] <- samdf.protein$row[sample]
}

# Now rebuild a subsetted phyloseq object
ps.menu.12 <- phyloseq(otu_table(asvtab.menu.12, taxa_are_rows = FALSE),
                       sample_data(ps.protein), # Now this matches
                       tax_table(ps.menu)) # Menu-specific taxonomy

# Remove any taxa that aren't present any longer
ps.menu.12 <- prune_taxa(taxa_sums(ps.menu.12) > 0, ps.menu.12)
ps.menu.12
```

There are `r ntaxa(ps.menu.12)` recorded in the menu in the 2 days prior to each sample, and `r ntaxa(ps.protein)` detected by metaproteomics.

Overlap between the two? Good-- this is pretty similar in overall number to the full dataset (not filtering by menu day-- that gave 69 intersecting taxon names). 

A bit tricky because not all options are compatibly named.  Try grouping to genus level to smooth over at least some of this.

```{r}
ps.menu.12 <- tax_glom(ps.menu.12, 'genus')
taxa_names(ps.menu.12) <- tax_table(ps.menu.12)[, 'genus']

ps.protein <- tax_glom(ps.protein, 'genus')
taxa_names(ps.protein) <- tax_table(ps.protein)[, 'genus']
```


#### TP

```{r}
tp <- intersect(taxa_names(ps.protein), taxa_names(ps.menu.12))
tp
```

```{r}
taxtab.protein <- tax_table(ps.protein)@.Data
# True positives by phylum
taxtab.protein[tp, ] %>% 
     data.frame() %>% 
     group_by(phylum) %>% 
     count() %>% 
     arrange(desc(n))
```

#### FN

```{r}
fn <- setdiff(taxa_names(ps.menu.12), taxa_names(ps.protein))
fn
```

```{r}
# False negatives by phylum
taxtab.menu.12 <- tax_table(ps.menu.12)@.Data
taxtab.menu.12[fn, ] %>% 
     data.frame() %>% 
     group_by(phylum) %>% 
     count() %>% 
     arrange(desc(n))
```
#### FP
```{r}
fp <- setdiff(taxa_names(ps.protein), taxa_names(ps.menu.12))
fp
```

False positives by phylum:
```{r}
taxtab.protein[fp, ] %>% 
     data.frame() %>% 
     group_by(phylum) %>% 
     count() %>% 
     arrange(desc(n))
```

### Paired samples, per-food

```{r}
# Make dataframe for storing results
metrics <- data.frame(subject = NULL, 
                      food = NULL,
                      n_compare = NULL,
                      tp = NULL,
                      tn = NULL,
                      fp = NULL,
                      fn = NULL)
```

```{r}
# Extract OTU tables
asvtab.protein <- otu_table(ps.protein)@.Data
asvtab.menu.12 <- otu_table(ps.menu.12)@.Data

# Synchronize names (not all genera in common between the two)
dim(asvtab.protein)
dim(asvtab.menu.12)
length(union(colnames(asvtab.menu.12), colnames(asvtab.protein)))
```

```{r}
# Helper function to pad out columns
pad_columns <- function(x, y, fill = 0){
     # Takes two matrices and synchronizes columns across them, filling added 
     # cols with a set value
     # Returns a list of the two updated matrices
     
     # Find missing columns in both matrices
     missing.x <- setdiff(colnames(y), colnames(x))
     missing.y <- setdiff(colnames(x), colnames(y))
     
     # Pad out columns of x
     fill.x <- matrix(fill, 
                      nrow = dim(x)[1],
                      ncol = length(missing.x))
     colnames(fill.x) <- missing.x 
     x <- cbind(x, fill.x)
     
     # Pad out columns of y
     fill.y <- matrix(fill, 
                      nrow = dim(y)[1],
                      ncol = length(missing.y))
     colnames(fill.y) <- missing.y
     y <- cbind(y, fill.y)
     
     # Arrange the columns so they appear in identical order
     u <- sort(union(colnames(x), colnames(y)))
     x <- x[, u]
     y <- y[, u]
     
     list(x, y)
}
```

```{r}
padded <- pad_columns(asvtab.protein, asvtab.menu.12)
asvtab.protein <- padded[[1]]
asvtab.menu.12 <- padded[[2]]

rm(padded)
```

```{r}
# Confirm row and column names are equal before proceeding
all(row.names(asvtab.protein) == row.names(asvtab.menu.12))
all(colnames(asvtab.protein) == colnames(asvtab.menu.12))
```

```{r}
# Label predictions 
protein.pos <- asvtab.protein > 0
menu.pos <- asvtab.menu.12 > 0

tp <- protein.pos & menu.pos
tn <- !protein.pos & !menu.pos
fp <- protein.pos & !menu.pos
fn <- !protein.pos & menu.pos

pred <- bind_rows(colSums(tp),
                  colSums(tn),
                  colSums(fp),
                  colSums(fn))

pred$prediction <- c('tp', 'tn', 'fp', 'fn')

pred <- select(pred, prediction, everything())
```

```{r}
# Reformat to long for visualization
pred.long <- pivot_longer(pred,
                          cols = -prediction,
                          names_to = 'taxon',
                          values_to = 'count')

# Factor data for visualization
# Calculate F-measure to be used downstream
pred.summary <- 
     pred.long %>% 
     pivot_wider(names_from = prediction, values_from = count) %>% 
     mutate(recall = tp/(tp + fn),
            precision = tp/(tp + fp),
            f_measure = (2 * recall * precision)/(recall + precision)) %>% 
     arrange(desc(f_measure), fn, fp)

# Assign label for faceting plot
# Done by manually inspecting pred.summary
breaks <- c(rep(1, 28), rep(2, 28), rep(3, 39), rep(4, 32))
pred.summary$facet <- breaks

pred.long <- 
     pred.summary %>% 
     select(taxon, facet) %>% 
     right_join(pred.long) %>% 
     select(facet, taxon, everything())

pred.long <- 
     pred.long %>% 
     mutate(taxon = factor(taxon, levels = pred.summary$taxon),
            prediction = factor(prediction, levels = c('tp', 'tn', 'fp', 'fn'),
                                labels = c('True positive', 'True negative',
                                           'False positive', 'False negative')))
```

```{r}
ggplot(pred.long, aes(x = taxon, y = count, fill = prediction)) +
     geom_bar(position = 'stack', stat = 'identity') +
     scale_fill_manual(values = c('#1A9850','#D73027', '#A6D96A', '#FDAE61')) +
     facet_wrap(~facet, nrow = 4, scale = 'free_x') +
     theme_bw() +
     theme(axis.text.x = element_text(angle = 45, hjust = 1),
           axis.text.y = element_blank(),
           axis.title = element_blank(),
           legend.position = 'top',
           legend.title = element_blank(), 
           plot.margin = margin(0, 0.5, 0.5, 0.5, 'in'),
           strip.text.x = element_blank()) 

plotID <- paste(Sys.Date(), as.character(sample(000:999,1)), sep=".")

ggsave(here('results', paste0(plotID, '_By-food predictions compared to menu.pdf')),
       height = 8, width = 8)
# 2021-02-22.677
```

