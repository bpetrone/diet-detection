---
title: "Kleiner lab database testing"
output:
  html_document:
    df_print: paged
---

Here we are evaluating the preliminary data shared by the Kleiner lab at NCSU to determine if their metaproteomic database should be adjusted (e.g. filtering out homologs to human proteins, other ideas?) before continuing with analysis of the DFC samples.

# Setup

```{r setup, include=FALSE, echo=FALSE}
require("knitr")
opts_knit$set(root.dir = file.path(getwd(), '..'))
```

```{r libraries, echo=FALSE}
library(here) 
library(phyloseq) 
library(RColorBrewer)
library(tidyverse) 
```

# Read in data

## Synchronized names

## Taxon name mapping

```{r}
name.sync <- 
     here('data',
          'processed',
          'Naming discrepancies.xlsx') %>% 
     readxl::read_excel()

name.sync
```

## Metabarcoding phyloseq

```{r}
ps.animal <- 
     here('data', 
          'processed', 
          'phyloseq',
          'combined',
          'filtered',
          'ps_mb_12SV5.rds') %>% 
     readRDS()
ps.animal

ps.plant <- 
     here('data', 
          'processed', 
          'phyloseq',
          'combined',
          'filtered',
          'ps_mb_trnL.rds') %>% 
     readRDS()

ps.plant
```

## Menu data phyloseq

```{r}
ps.menu <- 
     here('data', 
          'processed', 
          'phyloseq',
          'combined',
          'filtered',
          'ps_menu.rds') %>% 
     readRDS()

ps.menu
```

# Pre-process

## Metabarcoding

```{r}
# The 12SV5 data have a shifted taxonomy, I think I need to go back and figure 
# this out. Maybe due to assignTaxonomy()?
# Below, kingdom should be superkingdom, phylum should be kingdom.
# Think it's class that's throwing this off, for some should be Mammalia
ps.animal@tax_table@.Data

# Update accordingly
tax_table(ps.animal) <- 
     tax_table(ps.animal)@.Data %>% 
     data.frame() %>% 
     rownames_to_column(var = 'row') %>% 
     mutate(superkingdom = kingdom,
            kingdom = phylum,
            phylum = class) %>% 
     select(-class) %>% 
     select(superkingdom, kingdom, phylum, everything()) %>% 
     column_to_rownames(var = 'row') %>% 
     as.matrix()
```

```{r}
# Note failed trnL samples and relabel with NAs prior to merge
failed <- 
     which(sample_sums(ps.plant)==0) %>% 
     names()

asvtab.plant <- ps.plant@otu_table@.Data
asvtab.plant[failed, ] <- NA
otu_table(ps.plant) <- otu_table(asvtab.plant,
                                 taxa_are_rows = FALSE)

# Combine into a single object
ps.mb <- merge_phyloseq(ps.plant, ps.animal)
ps.mb

# Remove separated objects
rm(ps.plant, ps.animal)
```

## Menu

```{r}
# Group by taxon, omitting food group info
ps.menu <- 
     ps.menu %>% 
     tax_glom(taxrank = 'name')

# Update names, which previously included food group
taxa_names(ps.menu) <- tax_table(ps.menu)@.Data[, 'name']
```

## Pair with 1-2 days prior intake

For this broadest level comparison, let's look only at the two days prior to sampling.

```{r}
# These already exist in sample data:
sample_variables(ps.mb)
samdf.mb <- 
     sample_data(ps.mb) %>% 
     data.frame() %>% 
     rownames_to_column(var = 'row')
```

```{r}
# Can't use merge_samples on phyloseq here because some samples make up >1 merge

# Do manually on ASV table
asvtab.menu <- otu_table(ps.menu)@.Data
asvtab.menu.12 <- data.frame()

for (sample in seq(dim(samdf.mb)[1])){
     # Pull menu day -1
     one.before <- asvtab.menu[samdf.mb$delta1[sample], ]
     # Pull menu day -2
     two.before <- asvtab.menu[samdf.mb$delta2[sample], ]
     # Merge and place in new, aggregated OTU table
     asvtab.menu.12 <- rbind(asvtab.menu.12,
                             one.before + two.before)
     # Update food names (only has to be done once)
     if (sample == 1){names(asvtab.menu.12) <- names(one.before + two.before)}
     # Update sample name
     row.names(asvtab.menu.12)[sample] <- samdf.mb$row[sample]
}

# Now rebuild a subsetted phyloseq object
ps.menu.12 <- phyloseq(otu_table(asvtab.menu.12, taxa_are_rows = FALSE),
                       sample_data(ps.mb), # Now this matches
                       tax_table(ps.menu)) # Menu-specific taxonomy

# Remove any taxa that aren't present any longer
ps.menu.12 <- prune_taxa(taxa_sums(ps.menu.12) > 0, ps.menu.12)
ps.menu.12
```

There are `r ntaxa(ps.menu.12)` recorded in the menu in the 2 days prior to each sample, and `r ntaxa(ps.mb)` detected by metaproteomics.

## Reference taxa by their shared index

Will need to glom by the shared taxon name, because otherwise phyloseq object would have multiple instances of that taxon. 

So what I'll want to do here is join the taxon indices to the names to the taxonomy, and then glom there and rename in the object.

Here, use "mb_tomp_to_menu" column, which maps specifically between these two datasets.
```{r}
# Metabarcoding
tax_table(ps.mb) <- 
     name.sync %>% 
     select(mb_to_mp_to_menu, mb_taxa) %>% 
     right_join(data.frame(ps.mb@tax_table@.Data),
               by = c('mb_taxa' = 'name')) %>%
     distinct() %>% 
     column_to_rownames(var = 'mb_taxa') %>% 
     as.matrix()

ps.mb.id <- ps.mb
taxa_names(ps.mb.id) <- ps.mb.id@tax_table@.Data[, 'mb_to_mp_to_menu']
```
`
```{r}
# Synchronize menu to metabarcoding names
# Needs name column added
tax_table(ps.menu.12) <- 
     MButils::lowest_level(data.frame(ps.menu.12@tax_table@.Data)) %>% 
     as.matrix()

tax_table(ps.menu.12) <- 
     name.sync %>% 
     select(mb_to_mp_to_menu, menu_taxa) %>% 
     right_join(data.frame(ps.menu.12@tax_table@.Data), 
               by = c('menu_taxa' = 'name')) %>% 
     distinct() %>% 
     column_to_rownames(var = 'menu_taxa') %>% 
     as.matrix()
```

```{r}
# Get a list of these duplicates
dups <- 
     ps.menu.12@tax_table@.Data %>% 
     data.frame() %>% 
     filter(duplicated(mb_to_mp_to_menu)) %>% 
     pull(mb_to_mp_to_menu) %>% 
     unique()

dups
```

```{r}
ps.menu.12
merges = list()
for (taxon in dups){
     # Get the list of equivalent taxa at the species level for that food
     eq_taxa <- 
          ps.menu.12@tax_table@.Data %>% 
          data.frame() %>% 
          filter(mb_to_mp_to_menu == taxon) %>% 
          select(-mb_to_mp_to_menu) %>% 
          MButils::lowest_level() %>% 
          pull(name)
     
     merges <- append(merges, list(eq_taxa))
}

if (length(merges) == 1){
     # Just do one merge
      ps.menu.id <- merge_taxa(ps.menu.12, merges[[1]])
} else {
     # Merge once to make new phyloseq
     ps.menu.id <- merge_taxa(ps.menu.12, merges[[1]])
     # Then loop over remainder
     for (i in 2:length(merges)){
          ps.menu.id <- merge_taxa(ps.menu.id, merges[[i]])
     }
}

taxa_names(ps.menu.id) <- tax_table(ps.menu.id)[, 'mb_to_mp_to_menu']
ps.menu.id
```

# Analyze 

## Metaproteomics x menu

### All taxa

```{r}
# Extract OTU tables
asvtab.mb <- otu_table(ps.mb.id)@.Data
asvtab.menu.12 <- otu_table(ps.menu.id)@.Data

# Synchronize names
dim(asvtab.mb)
dim(asvtab.menu.12)
length(union(colnames(asvtab.menu.12), colnames(asvtab.mb)))
```

Want to make these tables the same same size (taking the union of their columns, and populating the new additions to each with zeros since the food wasn't detected in that dataset).

```{r}
# Helper function to pad out columns
pad_columns <- function(x, y, fill = 0){
     # Takes two matrices and synchronizes columns across them
     # Returns a list of the two updated matrices
     
     # Find missing columns in both matrices
     missing.x <- setdiff(colnames(y), colnames(x))
     missing.y <- setdiff(colnames(x), colnames(y))
     
     # Pad out columns of x
     fill.x <- matrix(fill, 
                      nrow = dim(x)[1],
                      ncol = length(missing.x))
     colnames(fill.x) <- missing.x 
     x <- cbind(x, fill.x)
     
     # Pad out columns of y
     fill.y <- matrix(fill, 
                      nrow = dim(y)[1],
                      ncol = length(missing.y))
     colnames(fill.y) <- missing.y
     y <- cbind(y, fill.y)
     
     # Arrange the columns so they appear in identical order
     u <- sort(union(colnames(x), colnames(y)))
     x <- x[, u]
     y <- y[, u]
     
     list(x, y)
}
```

```{r}
padded <- pad_columns(asvtab.mb, asvtab.menu.12)
asvtab.mb <- padded[[1]]
asvtab.menu.12 <- padded[[2]]

rm(padded)
```

Now, we've padded out these columns, but the ones that came from the menu and added to the metabarcoding data may contain plant info for the failed samples. 
```{r}
# Find these columns
different <- setdiff(taxa_names(ps.menu.id), taxa_names(ps.mb.id)) %>% sort()
different

# However, want to select only those that are plant-based (only failed samples
# from trnL, not 12SV5). Use taxonomy to judge:
menu.plants <- 
     ps.menu.id@tax_table@.Data %>% 
     data.frame() %>% 
     filter(kingdom == 'Viridiplantae') %>% 
     row.names()

different <- intersect(different, menu.plants)
```

```{r}
# Change the failed sample x padded plant column pairs to be NA in the 
# metabarcoding dataset
asvtab.mb[failed, different] <- NA
```

```{r}
# Confirm row and column names are equal before proceeding
all(row.names(asvtab.mb) == row.names(asvtab.menu.12))
all(colnames(asvtab.mb) == colnames(asvtab.menu.12))
```

```{r}
# Label predictions 
# If failed samples present (OTU table entries are NAs), need to define a 
# version of "&" that does not return FALSE for NA & FALSE 
and_na <- function(x, y){
     
     # Instead returns NA
     return <- NULL
     if (any(is.na(c(x,y)))){
          # If there's also FALSE, change the output
          if (FALSE %in% c(x, y)){
               return <- NA
          } else {
          # Otherwise keep as-is
               return <- x & y
          }
     } else {
          return <- x & y
     }
     
     return
}

dna.pos <- asvtab.mb > 0
menu.pos <- asvtab.menu.12 > 0

tp <- 
     mapply(and_na, dna.pos, menu.pos) %>% 
     matrix(nrow = nrow(dna.pos),
            dimnames = list(row.names(dna.pos),
                            colnames(dna.pos)))

tn <- 
     mapply(and_na, !dna.pos, !menu.pos) %>% 
     matrix(nrow = nrow(dna.pos),
            dimnames = list(row.names(dna.pos),
                            colnames(dna.pos)))
fp <- 
     mapply(and_na, dna.pos, !menu.pos) %>% 
     matrix(nrow = nrow(dna.pos),
            dimnames = list(row.names(dna.pos),
                            colnames(dna.pos)))

fn <- 
     mapply(and_na, !dna.pos, menu.pos) %>% 
     matrix(nrow = nrow(dna.pos),
            dimnames = list(row.names(dna.pos),
                            colnames(dna.pos)))
```

```{r}
# Group results by study and reorganize
reformat <- function(pred, label){
     # Relabel results with study (based on sample) and prediction type
     pred <- 
          data.frame(pred, check.names = FALSE) %>% 
          rownames_to_column(var = 'study') %>% 
          mutate(study = substr(study, 1, 2)) %>%  # 1st 2 chars: HD/ID
          group_by(study) %>% 
          summarize(across(.cols = everything(),
                           ~sum(.x, na.rm = TRUE))) %>% 
          mutate(prediction = label) %>% 
          select(study, prediction, everything())
     
     pred
}

tp <- reformat(tp, 'tp')
tn <- reformat(tn, 'tn')
fp <- reformat(fp, 'fp')
fn <- reformat(fn, 'fn')

pred <- bind_rows(tp, tn, fp, fn)
```

```{r}
# Reformat to long for visualization
pred.long <- pivot_longer(pred,
                          cols = -c(prediction, study),
                          names_to = 'common_name',
                          values_to = 'count')

# Factor data for visualization
# Calculate F-measure to be used downstream
# For this ranking, combine results from both cohorts
pred.summary <- 
     pred.long %>% 
     select(-study) %>% 
     group_by(prediction, common_name) %>% 
     summarize(count = sum(count)) %>% 
     pivot_wider(names_from = prediction, values_from = count) %>% 
     mutate(recall = tp/(tp + fn),
            precision = tp/(tp + fp),
            f_measure = (2 * recall * precision)/(recall + precision),
            pos_n = tp + fp) %>% 
     arrange(desc(f_measure), fn, fp)

pred.summary
```
```{r}
# Join to taxonomy to get kingdom-level info
# Make overall taxonomy matrix (combined menu and metaproteomics)
taxtab <- 
     bind_rows(
          data.frame(ps.menu.id@tax_table),
          data.frame(ps.mb.id@tax_table)
          ) %>% 
     select(kingdom, common_name = mb_to_mp_to_menu) %>% 
     mutate(kingdom = ifelse(kingdom %in% c('Metazoa',
                                            'Viridiplantae'),
                             yes = kingdom,
                             no = 'Other')) %>% 
     distinct()

pred.summary <- left_join(pred.summary, taxtab)
```

```{r}
# Incorporate into object
pred.long <- 
     pred.summary %>% 
     select(common_name, kingdom) %>% 
     right_join(pred.long) %>% 
     select(kingdom, common_name, everything())
```

```{r}
# Now that joins complete, add factor levels
pred.long <- 
     pred.long %>% 
     mutate(
          study = factor(study,
                         levels = c('ID', 'HD'),
                         labels = c('Intervention', 'Habitual')),
          common_name = factor(common_name, 
                               levels = pred.summary$common_name),
          prediction = factor(prediction, levels = c('tp',
                                                     'tn',
                                                     'fp',
                                                     'fn'),
                              labels = c('True positive',
                                         'True negative',
                                         'False positive',
                                         'False negative')),
          kingdom = factor(kingdom,
                           levels = c('Viridiplantae',
                                      'Metazoa',
                                      'Other')))
```

```{r}
# Save for comparison to metabarcoding data
saveRDS(pred.long,
        here('data', 
             'processed', 
             'performance-metrics', 
             'Metabarcoding v. menu predictions by shared food taxa, 1-2d prior, no intake filter.rds'))
```

#### Plot

##### Bar

```{r}
pred.long %>%
     ggplot(aes(x = common_name, y = count, fill = prediction)) +
     geom_bar(position = 'fill', stat = 'identity') +
     scale_fill_manual(values = c('#1A9641','#A6D96A', # TP, TN
                                  '#D7191C', '#FDAE61')) + # FP, FN
     facet_grid(cols = vars(kingdom),
                # rows = vars(study),
                scales = 'free',
                space = 'free') +
     theme_classic() +
     theme(axis.text.x = element_text(angle = 40, hjust = 1),
           axis.text.y = element_blank(), 
           axis.ticks = element_blank(),
           axis.line = element_blank(),
           axis.title = element_blank(),
           legend.position = 'none',
           legend.title = element_blank(), 
           plot.margin = margin(0, 0.5, 0.5, 0.5, 'in'),
           strip.background = element_blank()) 
```

```{r}
plotID <- paste(Sys.Date(), as.character(sample(000:999,1)), sep=".")

ggsave(here('results',
            'manuscript',
            '3',
            paste0(plotID,
                   '_Metabarcoding by-food predictions compared to menu.pdf')),
       height = 4, width = 24)
```

### Grouped: to species, family, genera

```{r}
rank_names(ps.menu.12)
rank_names(ps.mb)
```

```{r}
# Glom taxa at these levels (removing common-name labels first)
# Menu
tax_table(ps.menu.12) <- 
     ps.menu.12@tax_table@.Data %>% 
     data.frame() %>% 
     select(-mb_to_mp_to_menu) %>% 
     as.matrix()

menus <- 
     lapply(list('species', 'genus', 'family'),
            tax_glom,
            physeq = ps.menu.12)

# Metaproteomic
tax_table(ps.mb) <- 
     ps.mb@tax_table@.Data %>% 
     data.frame() %>% 
     select(-mb_to_mp_to_menu) %>% 
     as.matrix()

proteins <- 
     lapply(list('species', 'genus', 'family'),
            tax_glom,
            physeq = ps.mb) 
```

### Paired samples, per-food

```{r}
# Replace full phyloseq object with its OTU table
menus <- 
     lapply(menus, otu_table) %>% # otu_table-class object
     lapply(., slot, name = '.Data') # matrix

proteins <- 
     lapply(proteins, otu_table) %>% # otu_table-class object
     lapply(., slot, name = '.Data') # matrix
```

```{r}
# Check their dimensions
lapply(menus, dim)
lapply(proteins, dim)
```

Want to make these tables the same same size (taking the union of their columns, and populating the new additions to each with zeros since the food wasn't detected in that dataset). Use `pad_columns()` helper function defined above. 

```{r}
padded <- 
     mapply(
          pad_columns,
          menus,
          proteins
     )

menus <- list(padded[[1]], padded[[3]], padded[[5]])
proteins <- list(padded[[2]], padded[[4]], padded[[6]])
```

```{r}
# Label predictions 
# Recode detections or records as binary
menus.pos <- lapply(menus, function(x){x > 0})
proteins.pos <- lapply(proteins, function(x){x > 0})

tp <- mapply(function(record, detect){record & detect},
             menus.pos, 
             proteins.pos)

tn <- mapply(function(record, detect){!record & !detect},
             menus.pos, 
             proteins.pos)

fp <- mapply(function(record, detect){!record & detect},
             menus.pos, 
             proteins.pos)

fn <- mapply(function(record, detect){record & !detect},
             menus.pos, 
             proteins.pos)
```

```{r}
# Group results by study and reorganize
reformat <- function(pred, label){
     # Relabel results with study (based on sample) and prediction type
     pred <- 
          data.frame(pred, check.names = FALSE) %>% 
          rownames_to_column(var = 'study') %>% 
          mutate(study = substr(study, 1, 2)) %>%  # 1st 2 chars: HD/ID
          group_by(study) %>% 
          summarize(across(.cols = everything(),
                           ~sum(.x))) %>% 
          mutate(prediction = label) %>% 
          select(study, prediction, everything())
     
     pred
}

tp <- reformat(tp, 'tp')
tn <- reformat(tn, 'tn')
fp <- reformat(fp, 'fp')
fn <- reformat(fn, 'fn')

pred <- bind_rows(tp, tn, fp, fn)
```

```{r}
# Reformat to long for visualization
pred.long <- pivot_longer(pred,
                          cols = -c(prediction, study),
                          names_to = 'common_name',
                          values_to = 'count')

# Factor data for visualization
# Calculate F-measure to be used downstream
# For this ranking, combine results from both cohorts
pred.summary <- 
     pred.long %>% 
     select(-study) %>% 
     group_by(prediction, common_name) %>% 
     summarize(count = sum(count)) %>% 
     pivot_wider(names_from = prediction, values_from = count) %>% 
     mutate(recall = tp/(tp + fn),
            precision = tp/(tp + fp),
            f_measure = (2 * recall * precision)/(recall + precision),
            pos_n = tp + fp) %>% 
     # mutate(certain = ifelse(taxon %in% facet$family,
     # mutate(certain = ifelse(taxon %in% facet$genus,
     # mutate(certain = ifelse(taxon %in% unlist(facet), # At any taxonomic level
     #                         yes = 0,
     #                         no = 1)) %>%
     arrange(desc(f_measure), fn, fp)

pred.summary
```
```{r}
# Join to taxonomy to get kingdom-level info
# Make overall taxonomy matrix (combined menu and metaproteomics)
taxtab <- 
     bind_rows(
          data.frame(ps.menu.id@tax_table),
          data.frame(ps.mb.id@tax_table)
          ) %>% 
     select(kingdom, common_name = mp_to_menu) %>% 
     mutate(kingdom = ifelse(kingdom %in% c('Metazoa',
                                            'Viridiplantae'),
                             yes = kingdom,
                             no = 'Other')) %>% 
     distinct()

pred.summary <- left_join(pred.summary, taxtab)
```

```{r}
# Incorporate into object
pred.long <- 
     pred.summary %>% 
     select(common_name, kingdom) %>% 
     right_join(pred.long) %>% 
     select(kingdom, common_name, everything())
```

```{r}
# Now that joins complete, add factor levels
pred.long <- 
     pred.long %>% 
     mutate(
          study = factor(study,
                         levels = c('ID', 'HD'),
                         labels = c('Intervention', 'Habitual')),
          common_name = factor(common_name, 
                               levels = pred.summary$common_name),
          prediction = factor(prediction, levels = c('tp',
                                                     'tn',
                                                     'fp',
                                                     'fn'),
                              labels = c('True positive',
                                         'True negative',
                                         'False positive',
                                         'False negative')),
          kingdom = factor(kingdom,
                           levels = c('Viridiplantae',
                                      'Metazoa',
                                      'Other')))
```

```{r}
# Save for comparison to metabarcoding data
saveRDS(pred.long,
        here('data', 
             'processed', 
             'performance-metrics', 
             'Metaproteomic 1UP v. menu predictions by shared food taxa, 1-2d prior, >4 counts per taxon filter, no intake filter.rds'))
```
