---
title: "Kleiner lab database testing"
output:
  html_document:
    df_print: paged
---

Here we are evaluating the preliminary data shared by the Kleiner lab at NCSU to determine if their metaproteomic database should be adjusted (e.g. filtering out homologs to human proteins, other ideas?) before continuing with analysis of the DFC samples.

# Setup

```{r setup, include=FALSE, echo=FALSE}
require("knitr")
opts_knit$set(root.dir = file.path(getwd(), '..'))
```

```{r libraries, echo=FALSE}
library(here) 
library(phyloseq) 
library(RColorBrewer)
library(tidyverse) 
```

# Read in data

## Synchronized names

## Taxon name mapping

```{r}
name.sync <- 
     here('data',
          'processed',
          'Naming discrepancies.xlsx') %>% 
     readxl::read_excel()

name.sync
```

## Metaproteomic phyloseq

```{r}
ps.protein <- 
     here('data', 
          'processed', 
          'phyloseq',
          'combined',
          'filtered',
          # 'ps_mp_1PUP_taxa.rds') %>% # >=1 protein unique peptide
          'ps_mp_1UP_taxa.rds') %>% # >=1 unique peptide
     readRDS()
          
ps.protein
```

## Menu data phyloseq

```{r}
ps.menu <- 
     here('data', 
          'processed', 
          'phyloseq',
          'combined',
          'filtered',
          'ps_menu.rds') %>% 
     readRDS()

ps.menu
```

# Pre-process

## Pair with 1-2 days prior intake

For this broadest level comparison, let's look only at the two days prior to sampling.

```{r}
# These already exist in sample data:
sample_variables(ps.protein)
samdf.protein <- 
     sample_data(ps.protein) %>% 
     data.frame() %>% 
     rownames_to_column(var = 'row')
```

```{r}
# Can't use merge_samples on phyloseq here because some samples make up >1 merge

# Do manually on ASV table
asvtab.menu <- otu_table(ps.menu)@.Data
asvtab.menu.12 <- data.frame()

for (sample in seq(dim(samdf.protein)[1])){
     # Pull menu day -1
     one.before <- asvtab.menu[samdf.protein$delta1[sample], ]
     # Pull menu day -2
     two.before <- asvtab.menu[samdf.protein$delta2[sample], ]
     # Merge and place in new, aggregated OTU table
     asvtab.menu.12 <- rbind(asvtab.menu.12,
                             one.before + two.before)
     # Update food names (only has to be done once)
     if (sample == 1){names(asvtab.menu.12) <- names(one.before + two.before)}
     # Update sample name
     row.names(asvtab.menu.12)[sample] <- samdf.protein$row[sample]
}

# Now rebuild a subsetted phyloseq object
ps.menu.12 <- phyloseq(otu_table(asvtab.menu.12, taxa_are_rows = FALSE),
                       sample_data(ps.protein), # Now this matches
                       tax_table(ps.menu)) # Menu-specific taxonomy

# Remove any taxa that aren't present any longer
ps.menu.12 <- prune_taxa(taxa_sums(ps.menu.12) > 0, ps.menu.12)
ps.menu.12
```

There are `r ntaxa(ps.menu.12)` recorded in the menu in the 2 days prior to each sample, and `r ntaxa(ps.protein)` detected by metaproteomics.

## Reference taxa by their shared index

Will need to glom by the shared taxon name, because otherwise phyloseq object would have multiple instances of that taxon. 

So what I'll want to do here is join the taxon indices to the names to the taxonomy, and then glom there and rename in the object.

Here, use "mp_to_menu" column, which maps specifically between these two datasets.
```{r}
# Metaproteomics
tax_table(ps.protein) <- 
     name.sync %>% 
     select(mp_to_menu, mp_taxa) %>% 
     right_join(data.frame(ps.protein@tax_table@.Data),
               by = c('mp_taxa' = 'name')) %>%
     distinct() %>% 
     column_to_rownames(var = 'mp_taxa') %>% 
     as.matrix()
```

Doing a glom on shared name doesn't work if there's a higher taxonomic level that differs, e.g.
- Musa acuminata / banana
- Musa x paradisiaca / banana 
will both be preserved, when I actually want them to be merged

```{r}
# Get a list of these duplicates
dups <- 
     ps.protein@tax_table@.Data %>% 
     data.frame() %>% 
     filter(duplicated(mp_to_menu)) %>% 
     pull(mp_to_menu)

dups
```

```{r}
# Note this has to be done in a different way if there's >1 duplicate,
# see menu below
ps.protein
for (taxon in dups){
     # Get the list of equivalent taxa at the species level for that food
     eq_taxa <- 
          ps.protein@tax_table@.Data %>% 
          data.frame() %>% 
          filter(mp_to_menu == taxon) %>% 
          select(-mp_to_menu) %>% 
          MButils::lowest_level() %>% 
          pull(name)
     
     ps.protein.id <- merge_taxa(ps.protein, eq_taxa)
}

taxa_names(ps.protein.id) <- tax_table(ps.protein.id)[, 'mp_to_menu']
ps.protein.id
```

```{r}
# Synchronize menu to metaproteomic names
# Needs name column added
tax_table(ps.menu.12) <- 
     MButils::lowest_level(data.frame(ps.menu.12@tax_table@.Data)) %>% 
     as.matrix()

tax_table(ps.menu.12) <- 
     name.sync %>% 
     select(mp_to_menu, menu_taxa) %>% 
     right_join(data.frame(ps.menu.12@tax_table@.Data), 
               by = c('menu_taxa' = 'name')) %>% 
     distinct() %>% 
     column_to_rownames(var = 'menu_taxa') %>% 
     as.matrix()
```

```{r}
# Get a list of these duplicates
dups <- 
     ps.menu.12@tax_table@.Data %>% 
     data.frame() %>% 
     filter(duplicated(mp_to_menu)) %>% 
     pull(mp_to_menu)

dups
```

```{r}
ps.menu.12
merges = list()
for (taxon in dups){
     # Get the list of equivalent taxa at the species level for that food
     eq_taxa <- 
          ps.menu.12@tax_table@.Data %>% 
          data.frame() %>% 
          filter(mp_to_menu == taxon) %>% 
          select(-mp_to_menu) %>% 
          MButils::lowest_level() %>% 
          pull(name)
     
     merges <- append(merges, list(eq_taxa))
}

if (length(merges) == 1){
     # Just do one merge
      ps.menu.id <- merge_taxa(ps.menu.12, merges[[1]])
} else {
     # Merge once to make new phyloseq
     ps.menu.id <- merge_taxa(ps.menu.12, merges[[1]])
     # Then loop over remainder
     for (i in 2:length(merges)){
          ps.menu.id <- merge_taxa(ps.menu.id, merges[[i]])
     }
}

taxa_names(ps.menu.id) <- tax_table(ps.menu.id)[, 'mp_to_menu']
ps.menu.id
```

# Analyze 

## Metaproteomics x menu

### All taxa

```{r}
fp <- setdiff(taxa_names(ps.protein.id), taxa_names(ps.menu.id))
length(fp)
```

```{r}
# Pull these rows from the taxonomy table
taxtab.protein <- ps.protein.id@tax_table@.Data
fp.taxonomy <- taxtab.protein[fp, ]
fp.taxonomy %>% 
     data.frame() %>% 
     group_by(phylum) %>% 
     count() %>% 
     arrange(desc(n))
```
Interesting-- at least in this high-level view, it's mostly plants. 

```{r}
# What plants? Use this to ID fruits, below:
fp.taxonomy %>% 
     data.frame() %>% 
     filter(kingdom == 'Viridiplantae')
```
#### Flag foods for separate facet

```{r}
# Note that this was done for V3, which I assume is more permissive, so should work for V2? But also want to double-check.
fruits <- 
     # Joint in both
     c(
          'Ananas comosus', # Pineapple
          'Citrus reticulata', # Mandarin 
          'Citrus sinensis', # Orange
          'Citrus x paradisi', # Grapefruit
          'Fragaria x ananassa', # Strawberry
          'Malus domestica', # Apple
          'Mangifera indica', # Mango
          'Prunus avium', # Cherry
          'Prunus persica', # Peach
          'Punica granatum', # Pomegranate
          'Vitis vinifera', # Grape
          # From metaproteomics
          'Actinidia deliciosa', # Kiwi
          'Carica papaya', # Papaya
          'Citrullus lanatus', # Watermelon
          'Citrus maxima', # Pomelo
          'Musa acuminata', # Banana
          'Musa x paradisiaca', # Banana
          'Passiflora edulis', # Passionfruit
          'Psidium guajava', # Guava
          'Pyrus communis', # Pear
          'Selenicereus undatus', # Dragon fruit
          'Vitis rotundifolia', # Muscadine grape
          'Morus nigra', # Black mulberry
          # From menu
          'Ficus carica', # Fig
          'Prunus armeniaca', # Apricot
          'Vaccinium tenellum' # Blueberry
     )
            
beverages <- 
     c(
          'Camellia sinensis', # Tea
          'Coffea arabica', # Coffee
          'Coffea canephora', # Coffee
          'Humulus lupulus' # Hops (beer)
     )

other <- c('Cannabis sativa')
```

Note: had a few genus-level entries here that are written as species above instead, because there was a finer species-level entry that captured them, and it would have been hard to synchronize shift to family or genus level otherwise.  These were Coffea, Citrus, Musa, Prunus, Pyrus, and Fragaria.

```{r}
facet <- 
     c(fruits, beverages, other) %>% 
     data.frame(species = .)

# Get [family, genus] category of these foods from combined taxonomy (metaproteomics and menu)
# Join to taxonomy to get kingdom-level info
# Make overall taxonomy matrix (combined menu and metaproteomics)
taxtab <- 
     bind_rows(
          data.frame(ps.menu@tax_table),
          data.frame(ps.protein@tax_table)
          ) 

# Join level desired based on glom, above
taxtab <- 
     taxtab %>% 
     select(family, genus, species) %>% 
     distinct()

facet <- left_join(facet, taxtab)
```


```{r}
# Extract OTU tables
asvtab.protein <- otu_table(ps.protein.id)@.Data
asvtab.menu.12 <- otu_table(ps.menu.id)@.Data

# Synchronize names
dim(asvtab.protein)
dim(asvtab.menu.12)
length(union(colnames(asvtab.menu.12), colnames(asvtab.protein)))
```

Want to make these tables the same same size (taking the union of their columns, and populating the new additions to each with zeros since the food wasn't detected in that dataset).
```{r}
# Helper function to pad out columns
pad_columns <- function(x, y, fill = 0){
     # Takes two matrices and synchronizes columns across them, filling added 
     # cols with a set value
     # Returns a list of the two updated matrices
     
     # Find missing columns in both matrices
     missing.x <- setdiff(colnames(y), colnames(x))
     missing.y <- setdiff(colnames(x), colnames(y))
     
     # Pad out columns of x
     fill.x <- matrix(fill, 
                      nrow = dim(x)[1],
                      ncol = length(missing.x))
     colnames(fill.x) <- missing.x 
     x <- cbind(x, fill.x)
     
     # Pad out columns of y
     fill.y <- matrix(fill, 
                      nrow = dim(y)[1],
                      ncol = length(missing.y))
     colnames(fill.y) <- missing.y
     y <- cbind(y, fill.y)
     
     # Arrange the columns so they appear in identical order
     u <- sort(union(colnames(x), colnames(y)))
     x <- x[, u]
     y <- y[, u]
     
     list(x, y)
}
```

```{r}
padded <- pad_columns(asvtab.protein, asvtab.menu.12)
asvtab.protein <- padded[[1]]
asvtab.menu.12 <- padded[[2]]

rm(padded)
```

```{r}
# Confirm row and column names are equal before proceeding
all(row.names(asvtab.protein) == row.names(asvtab.menu.12))
all(colnames(asvtab.protein) == colnames(asvtab.menu.12))
```

```{r}
# Label predictions 
protein.pos <- asvtab.protein > 0
menu.pos <- asvtab.menu.12 > 0

tp <- protein.pos & menu.pos
tn <- !protein.pos & !menu.pos
fp <- protein.pos & !menu.pos
fn <- !protein.pos & menu.pos
```

```{r}
# Group results by study and reorganize
reformat <- function(pred, label){
     # Relabel results with study (based on sample) and prediction type
     pred <- 
          data.frame(pred, check.names = FALSE) %>% 
          rownames_to_column(var = 'study') %>% 
          mutate(study = substr(study, 1, 2)) %>%  # 1st 2 chars: HD/ID
          group_by(study) %>% 
          summarize(across(.cols = everything(),
                           ~sum(.x))) %>% 
          mutate(prediction = label) %>% 
          select(study, prediction, everything())
     
     pred
}

tp <- reformat(tp, 'tp')
tn <- reformat(tn, 'tn')
fp <- reformat(fp, 'fp')
fn <- reformat(fn, 'fn')

pred <- bind_rows(tp, tn, fp, fn)
```

```{r}
# Reformat to long for visualization
pred.long <- pivot_longer(pred,
                          cols = -c(prediction, study),
                          names_to = 'common_name',
                          values_to = 'count')

# Factor data for visualization
# Calculate F-measure to be used downstream
# For this ranking, combine results from both cohorts
pred.summary <- 
     pred.long %>% 
     select(-study) %>% 
     group_by(prediction, common_name) %>% 
     summarize(count = sum(count)) %>% 
     pivot_wider(names_from = prediction, values_from = count) %>% 
     mutate(recall = tp/(tp + fn),
            precision = tp/(tp + fp),
            f_measure = (2 * recall * precision)/(recall + precision),
            pos_n = tp + fp) %>% 
     # mutate(certain = ifelse(taxon %in% facet$family,
     # mutate(certain = ifelse(taxon %in% facet$genus,
     # mutate(certain = ifelse(taxon %in% unlist(facet), # At any taxonomic level
     #                         yes = 0,
     #                         no = 1)) %>%
     arrange(desc(f_measure), fn, fp)

pred.summary
```
```{r}
# Join to taxonomy to get kingdom-level info
# Make overall taxonomy matrix (combined menu and metaproteomics)
taxtab <- 
     bind_rows(
          data.frame(ps.menu.id@tax_table),
          data.frame(ps.protein.id@tax_table)
          ) %>% 
     select(kingdom, common_name = mp_to_menu) %>% 
     mutate(kingdom = ifelse(kingdom %in% c('Metazoa',
                                            'Viridiplantae'),
                             yes = kingdom,
                             no = 'Other')) %>% 
     distinct()

pred.summary <- left_join(pred.summary, taxtab)
```

```{r}
# Incorporate into object
pred.long <- 
     pred.summary %>% 
     select(common_name, kingdom) %>% 
     right_join(pred.long) %>% 
     select(kingdom, common_name, everything())
```

```{r}
# Now that joins complete, add factor levels
pred.long <- 
     pred.long %>% 
     mutate(
          study = factor(study,
                         levels = c('ID', 'HD'),
                         labels = c('Intervention', 'Habitual')),
          common_name = factor(common_name, 
                               levels = pred.summary$common_name),
          prediction = factor(prediction, levels = c('tp',
                                                     'tn',
                                                     'fp',
                                                     'fn'),
                              labels = c('True positive',
                                         'True negative',
                                         'False positive',
                                         'False negative')),
          kingdom = factor(kingdom,
                           levels = c('Viridiplantae',
                                      'Metazoa',
                                      'Other')))
```

```{r}
# Save for comparison to metabarcoding data
saveRDS(pred.long,
        here('data', 
             'processed', 
             'performance-metrics', 
             'Metaproteomic 1UP v. menu predictions by shared food taxa, 1-2d prior, >4 counts per taxon filter, no intake filter.rds'))
```

#### Plot

```{r}
pred.long %>%
     ggplot(aes(x = common_name, y = count, fill = prediction)) +
     geom_bar(position = 'stack', stat = 'identity') +
     scale_fill_manual(values = c('#1A9641','#A6D96A', # TP, TN
                                  '#D7191C', '#FDAE61')) + # FP, FN
     facet_grid(cols = vars(kingdom),
                rows = vars(study),
                scales = 'free',
                space = 'free') +
     theme_classic() +
     theme(axis.text.x = element_text(angle = 40, hjust = 1),
           axis.text.y = element_blank(), 
           axis.ticks = element_blank(),
           axis.line = element_blank(),
           axis.title = element_blank(),
           legend.position = 'none',
           legend.title = element_blank(), 
           plot.margin = margin(0, 0.5, 0.5, 0.5, 'in'),
           strip.background = element_blank()) 
```

```{r}
plotID <- paste(Sys.Date(), as.character(sample(000:999,1)), sep=".")

ggsave(here('results',
            'manuscript',
            '3',
            paste0(plotID,
                   '_Metaproteomic by-food predictions compared to menu.pdf')),
       height = 4, width = 24)
```

### Grouped: to species, family, genera

This repeats the above but vectorized over a list of objects, which contain the menu/protein information grouped to either the species, genus, or family level.

```{r}
rank_names(ps.menu.12)
rank_names(ps.protein)
```


```{r}
# Glom taxa at these levels (removing common-name labels first)
# Remove common name, which inhibits glom
tax_table(ps.menu.12) <- 
     ps.menu.12@tax_table@.Data %>% 
     data.frame() %>% 
     select(-mp_to_menu) %>% 
     as.matrix()

# Do glom
menus <- 
     lapply(list('species', 'genus', 'family'),
            tax_glom,
            physeq = ps.menu.12) 

# Rename taxa to the glommed level
taxa_names(menus[[1]]) <- tax_table(menus[[1]])@.Data[, 'species']
taxa_names(menus[[2]]) <- tax_table(menus[[2]])@.Data[, 'genus']
taxa_names(menus[[3]]) <- tax_table(menus[[3]])@.Data[, 'family']
```

```{r}
# Metaproteomic
tax_table(ps.protein) <- 
     ps.protein@tax_table@.Data %>% 
     data.frame() %>% 
     select(-mp_to_menu) %>% 
     as.matrix()

proteins <- 
     lapply(list('species', 'genus', 'family'),
            tax_glom,
            physeq = ps.protein)

taxa_names(proteins[[1]]) <- tax_table(proteins[[1]])@.Data[, 'species']
taxa_names(proteins[[2]]) <- tax_table(proteins[[2]])@.Data[, 'genus']
taxa_names(proteins[[3]]) <- tax_table(proteins[[3]])@.Data[, 'family']
```

```{r}
# Replace full phyloseq object with its OTU table
menus <- 
     lapply(menus, otu_table) %>% # otu_table-class object
     lapply(., slot, name = '.Data') # matrix

proteins <- 
     lapply(proteins, otu_table) %>% # otu_table-class object
     lapply(., slot, name = '.Data') # matrix
```

```{r}
# Check their dimensions
lapply(menus, dim)
lapply(proteins, dim)
```

Want to make these tables the same same size (taking the union of their columns, and populating the new additions to each with zeros since the food wasn't detected in that dataset). Use `pad_columns()` helper function defined above. 

```{r}
padded <- 
     mapply(
          pad_columns,
          menus,
          proteins
     )

menus <- list(padded[[1]], padded[[3]], padded[[5]])
proteins <- list(padded[[2]], padded[[4]], padded[[6]])
```

```{r}
# Confirm row and column names are equal before proceeding
for (i in 1:3){
     print(all(row.names(menus[[i]]) == row.names(proteins[[i]])))
     print(all(colnames(menus[[i]]) == colnames(proteins[[i]])))
}
```

```{r}
# Label predictions 
# Recode detections or records as binary
menus.pos <- lapply(menus, function(x){x > 0})
proteins.pos <- lapply(proteins, function(x){x > 0})

tp <- mapply(function(record, detect){record & detect},
             menus.pos, 
             proteins.pos)

tn <- mapply(function(record, detect){!record & !detect},
             menus.pos, 
             proteins.pos)

fp <- mapply(function(record, detect){!record & detect},
             menus.pos, 
             proteins.pos)

fn <- mapply(function(record, detect){record & !detect},
             menus.pos, 
             proteins.pos)
```

```{r}
# Group results by study and reorganize
reformat <- function(pred, label){
     # Relabel results with study (based on sample) and prediction type
     pred <- 
          data.frame(pred, check.names = FALSE) %>% 
          rownames_to_column(var = 'study') %>% 
          mutate(study = substr(study, 1, 2)) %>%  # 1st 2 chars: HD/ID
          group_by(study) %>% 
          summarize(across(.cols = everything(),
                           ~sum(.x))) %>% 
          mutate(prediction = label) %>% 
          select(study, prediction, everything())
     
     pred
}

tp <- lapply(tp, reformat, label = 'tp')
tn <- lapply(tn, reformat, label = 'tn')
fp <- lapply(fp, reformat, label = 'fp')
fn <- lapply(fn, reformat, label = 'fn')

pred <- 
     mapply(bind_rows, 
            tp, 
            tn, 
            fp,
            fn)
```

```{r}
# Reformat to long for visualization
pred.long <- 
     lapply(pred,
            pivot_longer,
            cols = -c(prediction, study),
            names_to = 'name',
            values_to = 'count')
```

```{r}
# Factor data for visualization
# Calculate F-measure to be used downstream
# For this ranking, combine results from both cohorts
summary_helper <- function(p){
     # p: pred.long: Long-form summary of per-taxon predictions
     p %>% 
     select(-study) %>% 
     group_by(prediction, name) %>% 
     summarize(count = sum(count)) %>% 
     pivot_wider(names_from = prediction, values_from = count) %>% 
     mutate(recall = tp/(tp + fn),
            precision = tp/(tp + fp),
            f_measure = (2 * recall * precision)/(recall + precision),
            pos_n = tp + fp) %>% 
     arrange(desc(f_measure), fn, fp)
     }

pred.summary <- lapply(pred.long, summary_helper)
```

```{r}
# Join to taxonomy to get kingdom-level info
# Make overall taxonomy matrix (combined menu and metaproteomics)
taxtabs <- 
     bind_rows(
          data.frame(ps.menu.12@tax_table),
          data.frame(ps.protein@tax_table)
          ) %>% 
     # Pair kingdom with either species, genus, or family label
     # for downstream join
     lapply(list('species', 'genus', 'family'),
            select, 
            .data = .,
            kingdom) %>% 
     lapply(.,
            distinct) %>% 
     # "Other": fungi and bacteria
     lapply(.,
            mutate,
            kingdom = ifelse(!(kingdom %in% c('Viridiplantae',
                                              'Metazoa')),
                             yes = 'Other',
                             no = kingdom))
```

```{r}
# Incorporate kingdom into objects
# Rename name to the specific taxonomic level relevant to that dataframe
pred.long[[1]] <- rename(pred.long[[1]], species = name)
pred.long[[2]] <- rename(pred.long[[2]], genus = name)
pred.long[[3]] <- rename(pred.long[[3]], family = name)

pred.long <- 
     mapply(left_join,
            pred.long,
            taxtabs) %>% 
     # Matrix output, reorganize into 3 dataframes
     apply(2, data.frame) %>% 
     # Rename taxon column, which was reset to "species" by prior step
     lapply(.,
            rename,
            name = species)
```

```{r}
# Now that joins complete, add factor levels
pred.long <- 
     lapply(pred.long, 
            mutate,
            study = factor(study,
                         levels = c('ID', 'HD'),
                         labels = c('Intervention', 'Habitual')),
            prediction = factor(prediction, levels = c('tp',
                                                       'tn',
                                                       'fp',
                                                       'fn'),
                                labels = c('True positive',
                                           'True negative',
                                           'False positive',
                                           'False negative')),
            kingdom = factor(kingdom,
                             levels = c('Viridiplantae',
                                        'Metazoa',
                                        'Other'))
     )
```
      
```{r}
# Refactor taxa to rank them by descending F measure (info from pred.summary)
for (i in 1:3){
     pred.long[[i]]$name <- factor(pred.long[[i]]$name,
                                   levels = pred.summary[[i]]$name)
}

names(pred.long) <- c('species', 'genera', 'families')
```

Okay, so now I should be able to iterate over these objects to plot them.

#### Plot

```{r}
plotID <- paste(Sys.Date(), as.character(sample(000:999,1)), sep=".")
for (i in 1:3){
 ggplot(pred.long[[i]],
        aes(x = name, y = count, fill = prediction)) +
          geom_bar(position = 'stack', stat = 'identity') +
          scale_fill_manual(values = c('#1A9641','#A6D96A', # TP, TN
                                       '#D7191C', '#FDAE61')) + # FP, FN
          facet_grid(cols = vars(kingdom),
                     rows = vars(study),
                     scales = 'free',
                     space = 'free') +
          theme_classic() +
          theme(axis.text.x = element_text(angle = 40, hjust = 1),
                axis.text.y = element_blank(), 
                axis.ticks = element_blank(),
                axis.line = element_blank(),
                axis.title = element_blank(),
                legend.position = 'none',
                legend.title = element_blank(), 
                plot.margin = margin(0, 0.5, 0.5, 0.5, 'in'),
                strip.background = element_blank())    
     
     ggsave(here('results',
                 'manuscript',
                 '3',
                 paste0(plotID,
                        '_Metaproteomic ',
                        names(pred.long)[i],
                        ' predictions compared to menu.pdf')),
            height = 4, width = 20)
}
```
