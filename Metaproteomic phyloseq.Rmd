---
title: "Make metaproteomic phyloseq"
output: html_notebook
---

This notebook makes a phyloseq object from the output of the metaproteomic analysis shared by Ali.  This currently exists in 3 versions:
     - 1
     - 2
     - 3

# R setup

```{r setup, include=FALSE, echo=FALSE}
require("knitr")
opts_knit$set(root.dir = file.path(getwd(), '..'))
```

```{r libraries, echo=FALSE}
library(here) 
library(phyloseq) 
library(readxl) # For parsing Excel files
library(tidyverse) 
```

# Read in files

## Current reference database

```{r }
# Read in the first sheet of the file using read_excel function
db <- read_excel(here('data', 'processed', 'DietaryDB_ForDavidLab.xlsx'), 
                 sheet = 1, 
                 n_max = 547) # Exclude annotations at end of file
head(db)
```
```{r }
# Manual updates
# Specify scientific name for tilapia
db$scientific_name[db$scientific_name == 'Tilapia'] <- 
     'Oreochromis niloticus'
# Correct misspelling for mallard duck
db$scientific_name[db$scientific_name == 'Anas platyrhynchose'] <- 
     'Anas platyrhynchos'
# Switch var. to subsp. for durum
db$scientific_name[db$scientific_name == 'Triticum turgidum var. durum'] <-
     'Triticum turgidum subsp. durum'
db$scientific_name[db$scientific_name == 'Triticum dicoccon'] <- 
     'Triticum dicoccum'
# Correct spelling of water buffalo
db$scientific_name[db$scientific_name == 'Bubalis bubalis'] <- 
     'Bubalus bubalis'
# Think something weird about formatting of "x" in Musa x paradisiaca, not being recognized
db$scientific_name[db$common_name == 'plantain'] <- 
     'Musa x paradisiaca'
# Same for Mentha x piperita
db$scientific_name[db$common_name == 'peppermint'] <- 
     'Mentha x piperita'
# Add hybrid designation for grapefruit
db$scientific_name[db$scientific_name == 'Citrus paradisi'] <- 
     'Citrus x paradisi'
# Remove zante currant, which is redundant with V. vinifera
db <- filter(db, common_name != 'zante currant')
# Switch amaranth to its homotypic synonym used by NCBI taxonomy
db$scientific_name[db$scientific_name == 'Amaranthus cruentus'] <- 
     'Amaranthus hybridus subsp. cruentus'
db$scientific_name[db$scientific_name == 'Mercenaria mercenaria, others'] <-
     'Mercenaria mercenaria'
db$scientific_name[db$scientific_name == 'Polystichum munitum and others'] <-
     'Polystichum munitum'
# Query resulted in hits for var. capitata only
db$scientific_name[db$scientific_name == 'Brassica oleracea var. capitata f. alba'] <- 
     'Brassica oleracea var. capitata'
# Switch fennel to its synonym used by NCBI taxonomy
db$scientific_name[db$scientific_name == 'Foeniculum vulgare'] <- 
     'Anethum foeniculum'
# Correct name for dragonfruit
db$scientific_name[db$scientific_name == 'Hylocereus undatus'] <- 
     'Selenicereus undatus'
# Update name for nori
db$scientific_name[db$scientific_name == 'Pyropia yezoensis'] <- 
     'Neopyropia yezoensis'
# Subspecies designation for maple (syrup)
db$scientific_name[db$scientific_name == 'Acer nigrum'] <- 
     'Acer saccharum subsp. nigrum'
``` 

```{r}
# Some entries have trailing whitespace: correct
db$scientific_name[grep('\\s$', db$scientific_name)]
db$scientific_name <- gsub('\\s$', '', db$scientific_name)
```

## Participant metaproteomic data

### Combine files

```{r }
# List files
fs <-
     here('data', 'raw',
          # '2_NewDataForDavidLab_DB2.1Search_Workflow2.0') %>%
          '3_DB2.1_5FDR_1UniquePeptide') %>%
     list.files(pattern = ".xlsx", full.names = T)

# Read and synchronize names
# Note that if sheet not specified, defaults to first sheet
dfs <- 
     lapply(fs, read_excel) %>% 
     # Rename "Found in sample" column so it's the same for each sample
     lapply(., 
            function(x){
                 # Update name
                 names(x)[grep('Found in Sample: *', names(x))] <- 'Found in Sample'
                 # Return original object
                 x
                 }
            )

# Bind together
names(dfs) <- basename(fs)
proteins.df <- bind_rows(dfs, .id = 'id')
rm(fs, dfs)
```

### Clean
```{r }
proteins.df <- 
     proteins.df %>% 
     # Clean up ID column
     separate(col = 'id', into = c('id', 'subj', 'date'),
                        sep = '_', remove = TRUE, extra = 'drop') %>% 
     # Convert date to Date type
     mutate(date = as.Date(date, format = '%d%b%y'))
```

```{r }
head(proteins.df)
```
```{r }
dim(proteins.df)
```

* 1_Proteins_IndividualResultFiles_RealisticFoodsWithMicrobiota: ??
* 2_NewDataForDavidLab_DB2.1Search_Workflow2.0: 7,632
* 3_DB2.1_5FDR_1UniquePeptide: 88,409

### Filter 

```{r }
# Filter to only food-derived proteins (this removes majority)
proteins.df <- 
     proteins.df %>% 
     filter(!grepl('Human_*', Accession)) %>% # Remove human proteins
     filter(!grepl('Microbiota_*', Accession)) # Remove microbiota proteins

dim(proteins.df)
```

```{r }
# Remove proteins labeled as not found in sample
# Very low abundance (though non-zero counts), only one from wheat
proteins.df <- 
     filter(proteins.df, 
            `Found in Sample` %in% c('High', 'Medium', NA))

dim(proteins.df)
```

### Relabel with food species

Using a combination of OS (embedded in Description column) and prefix assigned in database.

```{r }
head(proteins.df$Description)
cat('\n')
head(proteins.df$Accession)
```

```{r }
# Separate prefix into its own column

# Helper function for use inside mutate
helper <- function(str, ex){
     substring <- str_match(str, ex)
     substring[, 2] # Second column has capture group
}

# Extract prefix before '_'
proteins.df <- mutate(proteins.df, prefix = helper(Accession, '(\\w+)_.*'))
```

```{r }
# How many missing entries?
sum(is.na(proteins.df$prefix))
```

```{r }
# Extract OS from Description column
proteins.df <- mutate(proteins.df, OS = helper(Description, 'OS=(.*)\\sOX='))
```

```{r }
filter(proteins.df, is.na(prefix)) %>% pull(OS) %>% unique() %>% sort()
```

In some cases, the OS is more specific than it should be to match back to database. There is one prefix typo: Piper nigrum should be Pni, not Pne
```{r }
# Manual correction to match database 

proteins.df$OS[proteins.df$OS == 'Vigna radiata var. radiata'] <- 'Vigna radiata'
proteins.df$OS[proteins.df$OS == 'Mentha piperita'] <- 'Mentha x piperita'
proteins.df$prefix[proteins.df$OS == 'Piper nigrum'] <- 'Pni'
```

On first pass through, dimensions after join didn't check out-- turns out there are some prefixes with duplicated entries. Only Pgr and Shi come up here

Pgr: Assigned to both Prunus grayana (japanese bird cherry) and Punica granatum (pomegranate)
Shi: Assigned to both Salvia hispanica (chia) and Scorzonera hispanica (salsify)
Scer: Saccharomyces cerevisiae (yeast) and Secale cereale (rye)
Sso: Salsola soda (saltwort) and Smallanthus sonchifolius (yacon)
Vvi: Vaccinium vitis-idaea (lingonberry) and Vitis vinifera (grape)

```{r }
# Label with prefix unless unavailable; otherwise label by OS

# Join by prefix
join.prefix <- 
     proteins.df %>% 
     # Remove rows without a prefix label
     filter(!is.na(prefix)) %>% 
     # Remove any duplicated prefixes based on initial results
     filter(!(prefix %in% c('Pgr', 'Shi', 'Scer', 'Sso', 'Vvi'))) %>%
     left_join(select(db, scientific_name:category, `PreFix Used`), 
               by = c('prefix' = 'PreFix Used'))

# How many should there be?
proteins.df %>% 
     # Get missed rows in last join
     filter(!is.na(prefix)) %>% 
     # Remove any duplicated prefixes based on initial results
     filter(!(prefix %in% c('Pgr', 'Shi', 'Scer', 'Sso', 'Vvi'))) %>% 
     dim()

# How many are there?
dim(join.prefix)
```

```{r }
# Now, find those entries not joined by prefix, and join by OS instead
join.os <- 
     proteins.df %>% 
     # Get missed rows in last join
     filter(is.na(prefix) | prefix %in% c('Pgr', 'Shi', 'Scer', 
                                          'Sso', 'Vvi')) %>% 
     left_join(select(db, scientific_name:category),
               by = c('OS' = 'scientific_name')) %>% 
     rename(scientific_name = OS)

# Check dimensions are appropriate
cat('Combined dimensions of OS and prefix entries:', dim(join.os)[1] + dim(join.prefix)[1], '\n')
cat('Dimensions of input:', dim(proteins.df)[1])
```

Note that these dimensions may work even with some common name and category entries being empty if the food wasn't in the reference (think this is happening most commonly for fish queried at the family level, and returned at the species level).  

```{r }
# Bind together OS- and prefix-based joins to return to the full dataset

# Drop prefix columns 
join.prefix <- select(join.prefix, -c(prefix, OS))
join.os <- select(join.os, -prefix)

# Check all columns the same
all(names(join.prefix) == names(join.os))

# Join
proteins.df <- bind_rows(join.os, join.prefix)
dim(proteins.df) # How many entries?
any(is.na(proteins.df$scientific_name)) # Any missing entries?
```

### Format as phyloseq object

#### Sample data

```{r }
samdf <-
     proteins.df %>%
     mutate(sample = paste(subj, date, sep = '_')) %>%
     select(subj, date, sample) %>%
     distinct() %>% # Remove duplicated rows
     column_to_rownames(var = 'sample')
```

#### OTU table

```{r }
psm.counts.wide <-
     proteins.df %>%
     mutate(sample = paste(subj, date, sep = '_')) %>% # Create unique label
     # Need to group & summarize, because may be multiple peptides/food
     group_by(sample, scientific_name) %>%
     summarize(abundance = sum(`# PSMs`)) %>%
     pivot_wider(names_from = scientific_name,
                 values_from = abundance, # Total # PSMs
                 values_fill = 0) %>% # If no entry, log as 0
     column_to_rownames(var = 'sample')
```

#### Taxonomy table

Regardless of whether I go on to use taxids as names, I do need to query to build the taxonomy table for the phyloseq object.
```{r }
binomial.only <-
     proteins.df %>%
     select(scientific_name) %>%
     distinct()

taxids <- taxa::lookup_tax_data(binomial.only,
                                type = 'taxon_name',
                                column = 'scientific_name',
                                database = 'ncbi')
```

What wasn't found?
```{r }
result <- taxids$data$query_data
result$scientific_name[result$taxon_id == 'unknown']
```

Get taxonomy
```{r }
taxtab.protein <-
     taxa::taxonomy_table(taxids,
                          use_ranks = c('superkingdom', 'kingdom', 'phylum', 
                                        'class', 'superorder', 
                                        'order', 'superfamily', 
                                        'family', 'subfamily', 
                                        'genus', 'species', 
                                        'subspecies', 'varietas'),
                          add_id_col = TRUE)
```

Note that not all taxids are terminally listed here:
```{r }
dim(taxtab.protein)[1]
length(unique(taxids$data$query_data$taxon_id))
```

This is because some are internal nodes. Manually add their taxonomy too:

```{r }
add <- setdiff(unique(taxids$data$query_data$taxon_id), taxtab.protein$taxon_id)

# Manually inspect
taxids$data$query_data %>%
     filter(taxon_id %in% add) %>% View()

# Write full table, subset these columns out
# write_csv(taxtab.protein,
#           here('data', 'processed',
#                '20210727_Internal taxonomy table nodes.csv'))

add.rows <-
     here('data', 'processed', 
          # '20210408_Internal taxonomy table nodes.csv') %>% # Analysis v2
          '20210727_Internal taxonomy table nodes.csv') %>% # Analysis v3
     read_csv(col_types = cols(.default = 'c'))
```

```{r }
# Bind together
taxtab.protein <-
        taxtab.protein %>%
        bind_rows(add.rows) %>%
        as.data.frame() # This is required in order for lowest level step to work-- so weird-- the code below doesn't seem to work on a tibble
```

Add lowest level name as row name

```{r }
# This gets the right-most, non-NA values
lowest.index <- max.col(!is.na(taxtab.protein), 'last')

# Make row-column pairs to pull and add to taxonomy
taxtab.protein$lowest.level <- taxtab.protein[cbind(seq_along(lowest.index),
                                            lowest.index)]

# Now drop taxid, and convert terminal name to row name
taxtab.protein <-
        taxtab.protein %>%
        select(-taxon_id) %>%
        column_to_rownames(var = 'lowest.level')
```

```{r }
# Check everything matches
setdiff(names(psm.counts.wide), row.names(taxtab.protein))
setdiff(row.names(taxtab.protein), names(psm.counts.wide))
```

```{r }
# Make phyloseq object
ps.protein <- phyloseq(otu_table(psm.counts.wide, taxa_are_rows = FALSE),
                       sample_data(samdf),
                       tax_table(as.matrix(taxtab.protein)))

ps.protein

# saveRDS(ps.protein, 
#         here('data', 'processed', 'phyloseq', '20210727_ps_mp.rds'))
```